/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.31 from the
 * contents of XS.xs. Do not edit this file, edit XS.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "XS.xs"
#define PERL_NO_GET_CONTEXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "ppport.h"

#include <raylib.h>

#include "const-c.inc"

#line 22 "XS.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 166 "XS.c"

/* INCLUDE:  Including 'const-xs.inc' from 'XS.xs' */


XS_EUPXS(XS_Graphics__Raylib__XS_constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_constant)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 4 "./const-xs.inc"
#ifdef dXSTARG
	dXSTARG; /* Faster if we have it.  */
#else
	dTARGET;
#endif
	STRLEN		len;
        int		type;
	IV		iv;
	/* NV		nv;	Uncomment this if you need to return NVs */
	/* const char	*pv;	Uncomment this if you need to return PVs */
#line 191 "XS.c"
	SV *	sv = ST(0)
;
	const char *	s = SvPV(sv, len);
#line 18 "./const-xs.inc"
        /* Change this to constant(aTHX_ s, len, &iv, &nv);
           if you need to return both NVs and IVs */
	type = constant(aTHX_ s, len, &iv);
      /* Return 1 or 2 items. First is error message, or undef if no error.
           Second, if present, is found value */
        switch (type) {
        case PERL_constant_NOTFOUND:
          sv =
	    sv_2mortal(newSVpvf("%s is not a valid Graphics::Raylib::XS macro", s));
          PUSHs(sv);
          break;
        case PERL_constant_NOTDEF:
          sv = sv_2mortal(newSVpvf(
	    "Your vendor has not defined Graphics::Raylib::XS macro %s, used",
				   s));
          PUSHs(sv);
          break;
        case PERL_constant_ISIV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHi(iv);
          break;
	/* Uncomment this if you need to return NOs
        case PERL_constant_ISNO:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(&PL_sv_no);
          break; */
	/* Uncomment this if you need to return NVs
        case PERL_constant_ISNV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHn(nv);
          break; */
	/* Uncomment this if you need to return PVs
        case PERL_constant_ISPV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHp(pv, strlen(pv));
          break; */
	/* Uncomment this if you need to return PVNs
        case PERL_constant_ISPVN:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHp(pv, iv);
          break; */
	/* Uncomment this if you need to return SVs
        case PERL_constant_ISSV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(sv);
          break; */
	/* Uncomment this if you need to return UNDEFs
        case PERL_constant_ISUNDEF:
          break; */
	/* Uncomment this if you need to return UVs
        case PERL_constant_ISUV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHu((UV)iv);
          break; */
	/* Uncomment this if you need to return YESs
        case PERL_constant_ISYES:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(&PL_sv_yes);
          break; */
        default:
          sv = sv_2mortal(newSVpvf(
	    "Unexpected return type %d while processing Graphics::Raylib::XS macro %s, used",
               type, s));
          PUSHs(sv);
        }
#line 269 "XS.c"
	PUTBACK;
	return;
    }
}


/* INCLUDE: Returning to 'XS.xs' from 'const-xs.inc' */


XS_EUPXS(XS_Graphics__Raylib__XS_Begin2dMode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_Begin2dMode)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "camera");
    {
	Camera2D	camera;

	if (sv_derived_from(ST(0), "Camera2D")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(camera))
		croak("Size %d of packed data != expected %d",
			len, sizeof(camera));
	    camera = *(Camera2D *)s;
	}
	else
	    croak("camera is not of type Camera2D")
;

	Begin2dMode(camera);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_Begin3dMode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_Begin3dMode)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "camera");
    {
	Camera	camera;

	if (sv_derived_from(ST(0), "Camera")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(camera))
		croak("Size %d of packed data != expected %d",
			len, sizeof(camera));
	    camera = *(Camera *)s;
	}
	else
	    croak("camera is not of type Camera")
;

	Begin3dMode(camera);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_BeginBlendMode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_BeginBlendMode)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "mode");
    {
	int	mode = (int)SvIV(ST(0))
;

	BeginBlendMode(mode);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_BeginDrawing); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_BeginDrawing)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	BeginDrawing();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_BeginShaderMode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_BeginShaderMode)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "shader");
    {
	Shader	shader;

	if (sv_derived_from(ST(0), "Shader")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(shader))
		croak("Size %d of packed data != expected %d",
			len, sizeof(shader));
	    shader = *(Shader *)s;
	}
	else
	    croak("shader is not of type Shader")
;

	BeginShaderMode(shader);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_BeginTextureMode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_BeginTextureMode)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "target");
    {
	RenderTexture2D	target;

	if (sv_derived_from(ST(0), "RenderTexture2D")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(target))
		croak("Size %d of packed data != expected %d",
			len, sizeof(target));
	    target = *(RenderTexture2D *)s;
	}
	else
	    croak("target is not of type RenderTexture2D")
;

	BeginTextureMode(target);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_CalculateBoundingBox); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_CalculateBoundingBox)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "mesh");
    {
	Mesh	mesh;
	BoundingBox	RETVAL;

	if (sv_derived_from(ST(0), "Mesh")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(mesh))
		croak("Size %d of packed data != expected %d",
			len, sizeof(mesh));
	    mesh = *(Mesh *)s;
	}
	else
	    croak("mesh is not of type Mesh")
;

	RETVAL = CalculateBoundingBox(mesh);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "BoundingBox", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_CheckCollisionBoxSphere); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_CheckCollisionBoxSphere)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "box, centerSphere, radiusSphere");
    {
	BoundingBox	box;
	Vector3	centerSphere;
	float	radiusSphere = (float)SvNV(ST(2))
;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "BoundingBox")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(box))
		croak("Size %d of packed data != expected %d",
			len, sizeof(box));
	    box = *(BoundingBox *)s;
	}
	else
	    croak("box is not of type BoundingBox")
;

	if (sv_derived_from(ST(1), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(centerSphere))
		croak("Size %d of packed data != expected %d",
			len, sizeof(centerSphere));
	    centerSphere = *(Vector3 *)s;
	}
	else
	    croak("centerSphere is not of type Vector3")
;

	RETVAL = CheckCollisionBoxSphere(box, centerSphere, radiusSphere);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_CheckCollisionBoxes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_CheckCollisionBoxes)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "box1, box2");
    {
	BoundingBox	box1;
	BoundingBox	box2;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "BoundingBox")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(box1))
		croak("Size %d of packed data != expected %d",
			len, sizeof(box1));
	    box1 = *(BoundingBox *)s;
	}
	else
	    croak("box1 is not of type BoundingBox")
;

	if (sv_derived_from(ST(1), "BoundingBox")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(box2))
		croak("Size %d of packed data != expected %d",
			len, sizeof(box2));
	    box2 = *(BoundingBox *)s;
	}
	else
	    croak("box2 is not of type BoundingBox")
;

	RETVAL = CheckCollisionBoxes(box1, box2);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_CheckCollisionCircleRec); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_CheckCollisionCircleRec)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "center, radius, rec");
    {
	Vector2	center;
	float	radius = (float)SvNV(ST(1))
;
	Rectangle	rec;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(center))
		croak("Size %d of packed data != expected %d",
			len, sizeof(center));
	    center = *(Vector2 *)s;
	}
	else
	    croak("center is not of type Vector2")
;

	if (sv_derived_from(ST(2), "Rectangle")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(rec))
		croak("Size %d of packed data != expected %d",
			len, sizeof(rec));
	    rec = *(Rectangle *)s;
	}
	else
	    croak("rec is not of type Rectangle")
;

	RETVAL = CheckCollisionCircleRec(center, radius, rec);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_CheckCollisionCircles); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_CheckCollisionCircles)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "center1, radius1, center2, radius2");
    {
	Vector2	center1;
	float	radius1 = (float)SvNV(ST(1))
;
	Vector2	center2;
	float	radius2 = (float)SvNV(ST(3))
;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(center1))
		croak("Size %d of packed data != expected %d",
			len, sizeof(center1));
	    center1 = *(Vector2 *)s;
	}
	else
	    croak("center1 is not of type Vector2")
;

	if (sv_derived_from(ST(2), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(center2))
		croak("Size %d of packed data != expected %d",
			len, sizeof(center2));
	    center2 = *(Vector2 *)s;
	}
	else
	    croak("center2 is not of type Vector2")
;

	RETVAL = CheckCollisionCircles(center1, radius1, center2, radius2);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_CheckCollisionPointCircle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_CheckCollisionPointCircle)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "point, center, radius");
    {
	Vector2	point;
	Vector2	center;
	float	radius = (float)SvNV(ST(2))
;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(point))
		croak("Size %d of packed data != expected %d",
			len, sizeof(point));
	    point = *(Vector2 *)s;
	}
	else
	    croak("point is not of type Vector2")
;

	if (sv_derived_from(ST(1), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(center))
		croak("Size %d of packed data != expected %d",
			len, sizeof(center));
	    center = *(Vector2 *)s;
	}
	else
	    croak("center is not of type Vector2")
;

	RETVAL = CheckCollisionPointCircle(point, center, radius);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_CheckCollisionPointRec); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_CheckCollisionPointRec)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "point, rec");
    {
	Vector2	point;
	Rectangle	rec;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(point))
		croak("Size %d of packed data != expected %d",
			len, sizeof(point));
	    point = *(Vector2 *)s;
	}
	else
	    croak("point is not of type Vector2")
;

	if (sv_derived_from(ST(1), "Rectangle")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(rec))
		croak("Size %d of packed data != expected %d",
			len, sizeof(rec));
	    rec = *(Rectangle *)s;
	}
	else
	    croak("rec is not of type Rectangle")
;

	RETVAL = CheckCollisionPointRec(point, rec);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_CheckCollisionPointTriangle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_CheckCollisionPointTriangle)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "point, p1, p2, p3");
    {
	Vector2	point;
	Vector2	p1;
	Vector2	p2;
	Vector2	p3;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(point))
		croak("Size %d of packed data != expected %d",
			len, sizeof(point));
	    point = *(Vector2 *)s;
	}
	else
	    croak("point is not of type Vector2")
;

	if (sv_derived_from(ST(1), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(p1))
		croak("Size %d of packed data != expected %d",
			len, sizeof(p1));
	    p1 = *(Vector2 *)s;
	}
	else
	    croak("p1 is not of type Vector2")
;

	if (sv_derived_from(ST(2), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(p2))
		croak("Size %d of packed data != expected %d",
			len, sizeof(p2));
	    p2 = *(Vector2 *)s;
	}
	else
	    croak("p2 is not of type Vector2")
;

	if (sv_derived_from(ST(3), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(3)), len);
	    if (len != sizeof(p3))
		croak("Size %d of packed data != expected %d",
			len, sizeof(p3));
	    p3 = *(Vector2 *)s;
	}
	else
	    croak("p3 is not of type Vector2")
;

	RETVAL = CheckCollisionPointTriangle(point, p1, p2, p3);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_CheckCollisionRayBox); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_CheckCollisionRayBox)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "ray, box");
    {
	Ray	ray;
	BoundingBox	box;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Ray")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(ray))
		croak("Size %d of packed data != expected %d",
			len, sizeof(ray));
	    ray = *(Ray *)s;
	}
	else
	    croak("ray is not of type Ray")
;

	if (sv_derived_from(ST(1), "BoundingBox")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(box))
		croak("Size %d of packed data != expected %d",
			len, sizeof(box));
	    box = *(BoundingBox *)s;
	}
	else
	    croak("box is not of type BoundingBox")
;

	RETVAL = CheckCollisionRayBox(ray, box);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_CheckCollisionRaySphere); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_CheckCollisionRaySphere)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "ray, spherePosition, sphereRadius");
    {
	Ray	ray;
	Vector3	spherePosition;
	float	sphereRadius = (float)SvNV(ST(2))
;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Ray")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(ray))
		croak("Size %d of packed data != expected %d",
			len, sizeof(ray));
	    ray = *(Ray *)s;
	}
	else
	    croak("ray is not of type Ray")
;

	if (sv_derived_from(ST(1), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(spherePosition))
		croak("Size %d of packed data != expected %d",
			len, sizeof(spherePosition));
	    spherePosition = *(Vector3 *)s;
	}
	else
	    croak("spherePosition is not of type Vector3")
;

	RETVAL = CheckCollisionRaySphere(ray, spherePosition, sphereRadius);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_CheckCollisionRaySphereEx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_CheckCollisionRaySphereEx)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "ray, spherePosition, sphereRadius, collisionPoint");
    {
	Ray	ray;
	Vector3	spherePosition;
	float	sphereRadius = (float)SvNV(ST(2))
;
	Vector3 *	collisionPoint;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Ray")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(ray))
		croak("Size %d of packed data != expected %d",
			len, sizeof(ray));
	    ray = *(Ray *)s;
	}
	else
	    croak("ray is not of type Ray")
;

	if (sv_derived_from(ST(1), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(spherePosition))
		croak("Size %d of packed data != expected %d",
			len, sizeof(spherePosition));
	    spherePosition = *(Vector3 *)s;
	}
	else
	    croak("spherePosition is not of type Vector3")
;

	if (SvROK(ST(3)) && sv_derived_from(ST(3), "Vector3Ptr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(3)));
	    collisionPoint = INT2PTR(Vector3 *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::CheckCollisionRaySphereEx",
			"collisionPoint", "Vector3Ptr")
;

	RETVAL = CheckCollisionRaySphereEx(ray, spherePosition, sphereRadius, collisionPoint);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_CheckCollisionRecs); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_CheckCollisionRecs)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "rec1, rec2");
    {
	Rectangle	rec1;
	Rectangle	rec2;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Rectangle")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(rec1))
		croak("Size %d of packed data != expected %d",
			len, sizeof(rec1));
	    rec1 = *(Rectangle *)s;
	}
	else
	    croak("rec1 is not of type Rectangle")
;

	if (sv_derived_from(ST(1), "Rectangle")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(rec2))
		croak("Size %d of packed data != expected %d",
			len, sizeof(rec2));
	    rec2 = *(Rectangle *)s;
	}
	else
	    croak("rec2 is not of type Rectangle")
;

	RETVAL = CheckCollisionRecs(rec1, rec2);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_CheckCollisionSpheres); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_CheckCollisionSpheres)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "centerA, radiusA, centerB, radiusB");
    {
	Vector3	centerA;
	float	radiusA = (float)SvNV(ST(1))
;
	Vector3	centerB;
	float	radiusB = (float)SvNV(ST(3))
;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(centerA))
		croak("Size %d of packed data != expected %d",
			len, sizeof(centerA));
	    centerA = *(Vector3 *)s;
	}
	else
	    croak("centerA is not of type Vector3")
;

	if (sv_derived_from(ST(2), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(centerB))
		croak("Size %d of packed data != expected %d",
			len, sizeof(centerB));
	    centerB = *(Vector3 *)s;
	}
	else
	    croak("centerB is not of type Vector3")
;

	RETVAL = CheckCollisionSpheres(centerA, radiusA, centerB, radiusB);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_ClearBackground); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ClearBackground)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "color");
    {
	Color	color;

	if (sv_derived_from(ST(0), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	ClearBackground(color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_ClearDroppedFiles); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ClearDroppedFiles)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	ClearDroppedFiles();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_CloseAudioDevice); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_CloseAudioDevice)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	CloseAudioDevice();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_CloseAudioStream); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_CloseAudioStream)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "stream");
    {
	AudioStream	stream;

	if (sv_derived_from(ST(0), "AudioStream")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(stream))
		croak("Size %d of packed data != expected %d",
			len, sizeof(stream));
	    stream = *(AudioStream *)s;
	}
	else
	    croak("stream is not of type AudioStream")
;

	CloseAudioStream(stream);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_CloseVrDevice); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_CloseVrDevice)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	CloseVrDevice();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_CloseWindow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_CloseWindow)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	CloseWindow();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_ColorToFloat); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ColorToFloat)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "color");
    {
	Color	color;
	float *	RETVAL;

	if (sv_derived_from(ST(0), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	RETVAL = ColorToFloat(color);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "floatPtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_CreateLight); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_CreateLight)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "type, position, diffuse");
    {
	int	type = (int)SvIV(ST(0))
;
	Vector3	position;
	Color	diffuse;
	Light	RETVAL;

	if (sv_derived_from(ST(1), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(position))
		croak("Size %d of packed data != expected %d",
			len, sizeof(position));
	    position = *(Vector3 *)s;
	}
	else
	    croak("position is not of type Vector3")
;

	if (sv_derived_from(ST(2), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(diffuse))
		croak("Size %d of packed data != expected %d",
			len, sizeof(diffuse));
	    diffuse = *(Color *)s;
	}
	else
	    croak("diffuse is not of type Color")
;

	RETVAL = CreateLight(type, position, diffuse);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Light", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_DestroyLight); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DestroyLight)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "light");
    {
	Light	light;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Light")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    light = INT2PTR(Light,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::DestroyLight",
			"light", "Light")
;

	DestroyLight(light);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DisableCursor); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DisableCursor)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	DisableCursor();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawBillboard); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawBillboard)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "camera, texture, center, size, tint");
    {
	Camera	camera;
	Texture2D	texture;
	Vector3	center;
	float	size = (float)SvNV(ST(3))
;
	Color	tint;

	if (sv_derived_from(ST(0), "Camera")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(camera))
		croak("Size %d of packed data != expected %d",
			len, sizeof(camera));
	    camera = *(Camera *)s;
	}
	else
	    croak("camera is not of type Camera")
;

	if (sv_derived_from(ST(1), "Texture2D")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(texture))
		croak("Size %d of packed data != expected %d",
			len, sizeof(texture));
	    texture = *(Texture2D *)s;
	}
	else
	    croak("texture is not of type Texture2D")
;

	if (sv_derived_from(ST(2), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(center))
		croak("Size %d of packed data != expected %d",
			len, sizeof(center));
	    center = *(Vector3 *)s;
	}
	else
	    croak("center is not of type Vector3")
;

	if (sv_derived_from(ST(4), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(4)), len);
	    if (len != sizeof(tint))
		croak("Size %d of packed data != expected %d",
			len, sizeof(tint));
	    tint = *(Color *)s;
	}
	else
	    croak("tint is not of type Color")
;

	DrawBillboard(camera, texture, center, size, tint);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawBillboardRec); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawBillboardRec)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "camera, texture, sourceRec, center, size, tint");
    {
	Camera	camera;
	Texture2D	texture;
	Rectangle	sourceRec;
	Vector3	center;
	float	size = (float)SvNV(ST(4))
;
	Color	tint;

	if (sv_derived_from(ST(0), "Camera")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(camera))
		croak("Size %d of packed data != expected %d",
			len, sizeof(camera));
	    camera = *(Camera *)s;
	}
	else
	    croak("camera is not of type Camera")
;

	if (sv_derived_from(ST(1), "Texture2D")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(texture))
		croak("Size %d of packed data != expected %d",
			len, sizeof(texture));
	    texture = *(Texture2D *)s;
	}
	else
	    croak("texture is not of type Texture2D")
;

	if (sv_derived_from(ST(2), "Rectangle")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(sourceRec))
		croak("Size %d of packed data != expected %d",
			len, sizeof(sourceRec));
	    sourceRec = *(Rectangle *)s;
	}
	else
	    croak("sourceRec is not of type Rectangle")
;

	if (sv_derived_from(ST(3), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(3)), len);
	    if (len != sizeof(center))
		croak("Size %d of packed data != expected %d",
			len, sizeof(center));
	    center = *(Vector3 *)s;
	}
	else
	    croak("center is not of type Vector3")
;

	if (sv_derived_from(ST(5), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(5)), len);
	    if (len != sizeof(tint))
		croak("Size %d of packed data != expected %d",
			len, sizeof(tint));
	    tint = *(Color *)s;
	}
	else
	    croak("tint is not of type Color")
;

	DrawBillboardRec(camera, texture, sourceRec, center, size, tint);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawBoundingBox); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawBoundingBox)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "box, color");
    {
	BoundingBox	box;
	Color	color;

	if (sv_derived_from(ST(0), "BoundingBox")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(box))
		croak("Size %d of packed data != expected %d",
			len, sizeof(box));
	    box = *(BoundingBox *)s;
	}
	else
	    croak("box is not of type BoundingBox")
;

	if (sv_derived_from(ST(1), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawBoundingBox(box, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawCircle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawCircle)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "centerX, centerY, radius, color");
    {
	int	centerX = (int)SvIV(ST(0))
;
	int	centerY = (int)SvIV(ST(1))
;
	float	radius = (float)SvNV(ST(2))
;
	Color	color;

	if (sv_derived_from(ST(3), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(3)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawCircle(centerX, centerY, radius, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawCircle3D); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawCircle3D)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "center, radius, rotationAxis, rotationAngle, color");
    {
	Vector3	center;
	float	radius = (float)SvNV(ST(1))
;
	Vector3	rotationAxis;
	float	rotationAngle = (float)SvNV(ST(3))
;
	Color	color;

	if (sv_derived_from(ST(0), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(center))
		croak("Size %d of packed data != expected %d",
			len, sizeof(center));
	    center = *(Vector3 *)s;
	}
	else
	    croak("center is not of type Vector3")
;

	if (sv_derived_from(ST(2), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(rotationAxis))
		croak("Size %d of packed data != expected %d",
			len, sizeof(rotationAxis));
	    rotationAxis = *(Vector3 *)s;
	}
	else
	    croak("rotationAxis is not of type Vector3")
;

	if (sv_derived_from(ST(4), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(4)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawCircle3D(center, radius, rotationAxis, rotationAngle, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawCircleGradient); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawCircleGradient)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "centerX, centerY, radius, color1, color2");
    {
	int	centerX = (int)SvIV(ST(0))
;
	int	centerY = (int)SvIV(ST(1))
;
	float	radius = (float)SvNV(ST(2))
;
	Color	color1;
	Color	color2;

	if (sv_derived_from(ST(3), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(3)), len);
	    if (len != sizeof(color1))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color1));
	    color1 = *(Color *)s;
	}
	else
	    croak("color1 is not of type Color")
;

	if (sv_derived_from(ST(4), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(4)), len);
	    if (len != sizeof(color2))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color2));
	    color2 = *(Color *)s;
	}
	else
	    croak("color2 is not of type Color")
;

	DrawCircleGradient(centerX, centerY, radius, color1, color2);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawCircleLines); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawCircleLines)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "centerX, centerY, radius, color");
    {
	int	centerX = (int)SvIV(ST(0))
;
	int	centerY = (int)SvIV(ST(1))
;
	float	radius = (float)SvNV(ST(2))
;
	Color	color;

	if (sv_derived_from(ST(3), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(3)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawCircleLines(centerX, centerY, radius, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawCircleV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawCircleV)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "center, radius, color");
    {
	Vector2	center;
	float	radius = (float)SvNV(ST(1))
;
	Color	color;

	if (sv_derived_from(ST(0), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(center))
		croak("Size %d of packed data != expected %d",
			len, sizeof(center));
	    center = *(Vector2 *)s;
	}
	else
	    croak("center is not of type Vector2")
;

	if (sv_derived_from(ST(2), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawCircleV(center, radius, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawCube); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawCube)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "position, width, height, length, color");
    {
	Vector3	position;
	float	width = (float)SvNV(ST(1))
;
	float	height = (float)SvNV(ST(2))
;
	float	length = (float)SvNV(ST(3))
;
	Color	color;

	if (sv_derived_from(ST(0), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(position))
		croak("Size %d of packed data != expected %d",
			len, sizeof(position));
	    position = *(Vector3 *)s;
	}
	else
	    croak("position is not of type Vector3")
;

	if (sv_derived_from(ST(4), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(4)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawCube(position, width, height, length, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawCubeTexture); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawCubeTexture)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "texture, position, width, height, length, color");
    {
	Texture2D	texture;
	Vector3	position;
	float	width = (float)SvNV(ST(2))
;
	float	height = (float)SvNV(ST(3))
;
	float	length = (float)SvNV(ST(4))
;
	Color	color;

	if (sv_derived_from(ST(0), "Texture2D")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(texture))
		croak("Size %d of packed data != expected %d",
			len, sizeof(texture));
	    texture = *(Texture2D *)s;
	}
	else
	    croak("texture is not of type Texture2D")
;

	if (sv_derived_from(ST(1), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(position))
		croak("Size %d of packed data != expected %d",
			len, sizeof(position));
	    position = *(Vector3 *)s;
	}
	else
	    croak("position is not of type Vector3")
;

	if (sv_derived_from(ST(5), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(5)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawCubeTexture(texture, position, width, height, length, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawCubeV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawCubeV)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "position, size, color");
    {
	Vector3	position;
	Vector3	size;
	Color	color;

	if (sv_derived_from(ST(0), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(position))
		croak("Size %d of packed data != expected %d",
			len, sizeof(position));
	    position = *(Vector3 *)s;
	}
	else
	    croak("position is not of type Vector3")
;

	if (sv_derived_from(ST(1), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(size))
		croak("Size %d of packed data != expected %d",
			len, sizeof(size));
	    size = *(Vector3 *)s;
	}
	else
	    croak("size is not of type Vector3")
;

	if (sv_derived_from(ST(2), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawCubeV(position, size, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawCubeWires); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawCubeWires)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "position, width, height, length, color");
    {
	Vector3	position;
	float	width = (float)SvNV(ST(1))
;
	float	height = (float)SvNV(ST(2))
;
	float	length = (float)SvNV(ST(3))
;
	Color	color;

	if (sv_derived_from(ST(0), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(position))
		croak("Size %d of packed data != expected %d",
			len, sizeof(position));
	    position = *(Vector3 *)s;
	}
	else
	    croak("position is not of type Vector3")
;

	if (sv_derived_from(ST(4), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(4)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawCubeWires(position, width, height, length, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawCylinder); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawCylinder)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "position, radiusTop, radiusBottom, height, slices, color");
    {
	Vector3	position;
	float	radiusTop = (float)SvNV(ST(1))
;
	float	radiusBottom = (float)SvNV(ST(2))
;
	float	height = (float)SvNV(ST(3))
;
	int	slices = (int)SvIV(ST(4))
;
	Color	color;

	if (sv_derived_from(ST(0), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(position))
		croak("Size %d of packed data != expected %d",
			len, sizeof(position));
	    position = *(Vector3 *)s;
	}
	else
	    croak("position is not of type Vector3")
;

	if (sv_derived_from(ST(5), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(5)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawCylinder(position, radiusTop, radiusBottom, height, slices, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawCylinderWires); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawCylinderWires)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "position, radiusTop, radiusBottom, height, slices, color");
    {
	Vector3	position;
	float	radiusTop = (float)SvNV(ST(1))
;
	float	radiusBottom = (float)SvNV(ST(2))
;
	float	height = (float)SvNV(ST(3))
;
	int	slices = (int)SvIV(ST(4))
;
	Color	color;

	if (sv_derived_from(ST(0), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(position))
		croak("Size %d of packed data != expected %d",
			len, sizeof(position));
	    position = *(Vector3 *)s;
	}
	else
	    croak("position is not of type Vector3")
;

	if (sv_derived_from(ST(5), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(5)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawCylinderWires(position, radiusTop, radiusBottom, height, slices, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawFPS); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawFPS)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "posX, posY");
    {
	int	posX = (int)SvIV(ST(0))
;
	int	posY = (int)SvIV(ST(1))
;

	DrawFPS(posX, posY);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawGizmo); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawGizmo)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "position");
    {
	Vector3	position;

	if (sv_derived_from(ST(0), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(position))
		croak("Size %d of packed data != expected %d",
			len, sizeof(position));
	    position = *(Vector3 *)s;
	}
	else
	    croak("position is not of type Vector3")
;

	DrawGizmo(position);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawGrid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawGrid)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "slices, spacing");
    {
	int	slices = (int)SvIV(ST(0))
;
	float	spacing = (float)SvNV(ST(1))
;

	DrawGrid(slices, spacing);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawLight); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawLight)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "light");
    {
	Light	light;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Light")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    light = INT2PTR(Light,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::DrawLight",
			"light", "Light")
;

	DrawLight(light);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawLine); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawLine)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "startPosX, startPosY, endPosX, endPosY, color");
    {
	int	startPosX = (int)SvIV(ST(0))
;
	int	startPosY = (int)SvIV(ST(1))
;
	int	endPosX = (int)SvIV(ST(2))
;
	int	endPosY = (int)SvIV(ST(3))
;
	Color	color;

	if (sv_derived_from(ST(4), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(4)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawLine(startPosX, startPosY, endPosX, endPosY, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawLine3D); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawLine3D)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "startPos, endPos, color");
    {
	Vector3	startPos;
	Vector3	endPos;
	Color	color;

	if (sv_derived_from(ST(0), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(startPos))
		croak("Size %d of packed data != expected %d",
			len, sizeof(startPos));
	    startPos = *(Vector3 *)s;
	}
	else
	    croak("startPos is not of type Vector3")
;

	if (sv_derived_from(ST(1), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(endPos))
		croak("Size %d of packed data != expected %d",
			len, sizeof(endPos));
	    endPos = *(Vector3 *)s;
	}
	else
	    croak("endPos is not of type Vector3")
;

	if (sv_derived_from(ST(2), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawLine3D(startPos, endPos, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawLineV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawLineV)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "startPos, endPos, color");
    {
	Vector2	startPos;
	Vector2	endPos;
	Color	color;

	if (sv_derived_from(ST(0), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(startPos))
		croak("Size %d of packed data != expected %d",
			len, sizeof(startPos));
	    startPos = *(Vector2 *)s;
	}
	else
	    croak("startPos is not of type Vector2")
;

	if (sv_derived_from(ST(1), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(endPos))
		croak("Size %d of packed data != expected %d",
			len, sizeof(endPos));
	    endPos = *(Vector2 *)s;
	}
	else
	    croak("endPos is not of type Vector2")
;

	if (sv_derived_from(ST(2), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawLineV(startPos, endPos, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawModel); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawModel)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "model, position, scale, tint");
    {
	Model	model;
	Vector3	position;
	float	scale = (float)SvNV(ST(2))
;
	Color	tint;

	if (sv_derived_from(ST(0), "Model")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(model))
		croak("Size %d of packed data != expected %d",
			len, sizeof(model));
	    model = *(Model *)s;
	}
	else
	    croak("model is not of type Model")
;

	if (sv_derived_from(ST(1), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(position))
		croak("Size %d of packed data != expected %d",
			len, sizeof(position));
	    position = *(Vector3 *)s;
	}
	else
	    croak("position is not of type Vector3")
;

	if (sv_derived_from(ST(3), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(3)), len);
	    if (len != sizeof(tint))
		croak("Size %d of packed data != expected %d",
			len, sizeof(tint));
	    tint = *(Color *)s;
	}
	else
	    croak("tint is not of type Color")
;

	DrawModel(model, position, scale, tint);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawModelEx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawModelEx)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "model, position, rotationAxis, rotationAngle, scale, tint");
    {
	Model	model;
	Vector3	position;
	Vector3	rotationAxis;
	float	rotationAngle = (float)SvNV(ST(3))
;
	Vector3	scale;
	Color	tint;

	if (sv_derived_from(ST(0), "Model")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(model))
		croak("Size %d of packed data != expected %d",
			len, sizeof(model));
	    model = *(Model *)s;
	}
	else
	    croak("model is not of type Model")
;

	if (sv_derived_from(ST(1), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(position))
		croak("Size %d of packed data != expected %d",
			len, sizeof(position));
	    position = *(Vector3 *)s;
	}
	else
	    croak("position is not of type Vector3")
;

	if (sv_derived_from(ST(2), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(rotationAxis))
		croak("Size %d of packed data != expected %d",
			len, sizeof(rotationAxis));
	    rotationAxis = *(Vector3 *)s;
	}
	else
	    croak("rotationAxis is not of type Vector3")
;

	if (sv_derived_from(ST(4), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(4)), len);
	    if (len != sizeof(scale))
		croak("Size %d of packed data != expected %d",
			len, sizeof(scale));
	    scale = *(Vector3 *)s;
	}
	else
	    croak("scale is not of type Vector3")
;

	if (sv_derived_from(ST(5), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(5)), len);
	    if (len != sizeof(tint))
		croak("Size %d of packed data != expected %d",
			len, sizeof(tint));
	    tint = *(Color *)s;
	}
	else
	    croak("tint is not of type Color")
;

	DrawModelEx(model, position, rotationAxis, rotationAngle, scale, tint);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawModelWires); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawModelWires)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "model, position, scale, tint");
    {
	Model	model;
	Vector3	position;
	float	scale = (float)SvNV(ST(2))
;
	Color	tint;

	if (sv_derived_from(ST(0), "Model")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(model))
		croak("Size %d of packed data != expected %d",
			len, sizeof(model));
	    model = *(Model *)s;
	}
	else
	    croak("model is not of type Model")
;

	if (sv_derived_from(ST(1), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(position))
		croak("Size %d of packed data != expected %d",
			len, sizeof(position));
	    position = *(Vector3 *)s;
	}
	else
	    croak("position is not of type Vector3")
;

	if (sv_derived_from(ST(3), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(3)), len);
	    if (len != sizeof(tint))
		croak("Size %d of packed data != expected %d",
			len, sizeof(tint));
	    tint = *(Color *)s;
	}
	else
	    croak("tint is not of type Color")
;

	DrawModelWires(model, position, scale, tint);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawModelWiresEx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawModelWiresEx)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "model, position, rotationAxis, rotationAngle, scale, tint");
    {
	Model	model;
	Vector3	position;
	Vector3	rotationAxis;
	float	rotationAngle = (float)SvNV(ST(3))
;
	Vector3	scale;
	Color	tint;

	if (sv_derived_from(ST(0), "Model")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(model))
		croak("Size %d of packed data != expected %d",
			len, sizeof(model));
	    model = *(Model *)s;
	}
	else
	    croak("model is not of type Model")
;

	if (sv_derived_from(ST(1), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(position))
		croak("Size %d of packed data != expected %d",
			len, sizeof(position));
	    position = *(Vector3 *)s;
	}
	else
	    croak("position is not of type Vector3")
;

	if (sv_derived_from(ST(2), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(rotationAxis))
		croak("Size %d of packed data != expected %d",
			len, sizeof(rotationAxis));
	    rotationAxis = *(Vector3 *)s;
	}
	else
	    croak("rotationAxis is not of type Vector3")
;

	if (sv_derived_from(ST(4), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(4)), len);
	    if (len != sizeof(scale))
		croak("Size %d of packed data != expected %d",
			len, sizeof(scale));
	    scale = *(Vector3 *)s;
	}
	else
	    croak("scale is not of type Vector3")
;

	if (sv_derived_from(ST(5), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(5)), len);
	    if (len != sizeof(tint))
		croak("Size %d of packed data != expected %d",
			len, sizeof(tint));
	    tint = *(Color *)s;
	}
	else
	    croak("tint is not of type Color")
;

	DrawModelWiresEx(model, position, rotationAxis, rotationAngle, scale, tint);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawPixel); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawPixel)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "posX, posY, color");
    {
	int	posX = (int)SvIV(ST(0))
;
	int	posY = (int)SvIV(ST(1))
;
	Color	color;

	if (sv_derived_from(ST(2), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawPixel(posX, posY, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawPixelV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawPixelV)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "position, color");
    {
	Vector2	position;
	Color	color;

	if (sv_derived_from(ST(0), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(position))
		croak("Size %d of packed data != expected %d",
			len, sizeof(position));
	    position = *(Vector2 *)s;
	}
	else
	    croak("position is not of type Vector2")
;

	if (sv_derived_from(ST(1), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawPixelV(position, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawPlane); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawPlane)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "centerPos, size, color");
    {
	Vector3	centerPos;
	Vector2	size;
	Color	color;

	if (sv_derived_from(ST(0), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(centerPos))
		croak("Size %d of packed data != expected %d",
			len, sizeof(centerPos));
	    centerPos = *(Vector3 *)s;
	}
	else
	    croak("centerPos is not of type Vector3")
;

	if (sv_derived_from(ST(1), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(size))
		croak("Size %d of packed data != expected %d",
			len, sizeof(size));
	    size = *(Vector2 *)s;
	}
	else
	    croak("size is not of type Vector2")
;

	if (sv_derived_from(ST(2), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawPlane(centerPos, size, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawPoly); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawPoly)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "center, sides, radius, rotation, color");
    {
	Vector2	center;
	int	sides = (int)SvIV(ST(1))
;
	float	radius = (float)SvNV(ST(2))
;
	float	rotation = (float)SvNV(ST(3))
;
	Color	color;

	if (sv_derived_from(ST(0), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(center))
		croak("Size %d of packed data != expected %d",
			len, sizeof(center));
	    center = *(Vector2 *)s;
	}
	else
	    croak("center is not of type Vector2")
;

	if (sv_derived_from(ST(4), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(4)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawPoly(center, sides, radius, rotation, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawPolyEx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawPolyEx)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "points, numPoints, color");
    {
	Vector2 *	points;
	int	numPoints = (int)SvIV(ST(1))
;
	Color	color;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Vector2Ptr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    points = INT2PTR(Vector2 *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::DrawPolyEx",
			"points", "Vector2Ptr")
;

	if (sv_derived_from(ST(2), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawPolyEx(points, numPoints, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawPolyExLines); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawPolyExLines)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "points, numPoints, color");
    {
	Vector2 *	points;
	int	numPoints = (int)SvIV(ST(1))
;
	Color	color;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Vector2Ptr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    points = INT2PTR(Vector2 *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::DrawPolyExLines",
			"points", "Vector2Ptr")
;

	if (sv_derived_from(ST(2), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawPolyExLines(points, numPoints, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawRay); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawRay)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "ray, color");
    {
	Ray	ray;
	Color	color;

	if (sv_derived_from(ST(0), "Ray")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(ray))
		croak("Size %d of packed data != expected %d",
			len, sizeof(ray));
	    ray = *(Ray *)s;
	}
	else
	    croak("ray is not of type Ray")
;

	if (sv_derived_from(ST(1), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawRay(ray, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawRectangle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawRectangle)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "posX, posY, width, height, color");
    {
	int	posX = (int)SvIV(ST(0))
;
	int	posY = (int)SvIV(ST(1))
;
	int	width = (int)SvIV(ST(2))
;
	int	height = (int)SvIV(ST(3))
;
	Color	color;

	if (sv_derived_from(ST(4), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(4)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawRectangle(posX, posY, width, height, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawRectangleGradient); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawRectangleGradient)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "posX, posY, width, height, color1, color2");
    {
	int	posX = (int)SvIV(ST(0))
;
	int	posY = (int)SvIV(ST(1))
;
	int	width = (int)SvIV(ST(2))
;
	int	height = (int)SvIV(ST(3))
;
	Color	color1;
	Color	color2;

	if (sv_derived_from(ST(4), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(4)), len);
	    if (len != sizeof(color1))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color1));
	    color1 = *(Color *)s;
	}
	else
	    croak("color1 is not of type Color")
;

	if (sv_derived_from(ST(5), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(5)), len);
	    if (len != sizeof(color2))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color2));
	    color2 = *(Color *)s;
	}
	else
	    croak("color2 is not of type Color")
;

	DrawRectangleGradient(posX, posY, width, height, color1, color2);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawRectangleLines); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawRectangleLines)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "posX, posY, width, height, color");
    {
	int	posX = (int)SvIV(ST(0))
;
	int	posY = (int)SvIV(ST(1))
;
	int	width = (int)SvIV(ST(2))
;
	int	height = (int)SvIV(ST(3))
;
	Color	color;

	if (sv_derived_from(ST(4), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(4)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawRectangleLines(posX, posY, width, height, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawRectangleRec); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawRectangleRec)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "rec, color");
    {
	Rectangle	rec;
	Color	color;

	if (sv_derived_from(ST(0), "Rectangle")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(rec))
		croak("Size %d of packed data != expected %d",
			len, sizeof(rec));
	    rec = *(Rectangle *)s;
	}
	else
	    croak("rec is not of type Rectangle")
;

	if (sv_derived_from(ST(1), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawRectangleRec(rec, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawRectangleV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawRectangleV)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "position, size, color");
    {
	Vector2	position;
	Vector2	size;
	Color	color;

	if (sv_derived_from(ST(0), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(position))
		croak("Size %d of packed data != expected %d",
			len, sizeof(position));
	    position = *(Vector2 *)s;
	}
	else
	    croak("position is not of type Vector2")
;

	if (sv_derived_from(ST(1), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(size))
		croak("Size %d of packed data != expected %d",
			len, sizeof(size));
	    size = *(Vector2 *)s;
	}
	else
	    croak("size is not of type Vector2")
;

	if (sv_derived_from(ST(2), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawRectangleV(position, size, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawSphere); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawSphere)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "centerPos, radius, color");
    {
	Vector3	centerPos;
	float	radius = (float)SvNV(ST(1))
;
	Color	color;

	if (sv_derived_from(ST(0), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(centerPos))
		croak("Size %d of packed data != expected %d",
			len, sizeof(centerPos));
	    centerPos = *(Vector3 *)s;
	}
	else
	    croak("centerPos is not of type Vector3")
;

	if (sv_derived_from(ST(2), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawSphere(centerPos, radius, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawSphereEx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawSphereEx)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "centerPos, radius, rings, slices, color");
    {
	Vector3	centerPos;
	float	radius = (float)SvNV(ST(1))
;
	int	rings = (int)SvIV(ST(2))
;
	int	slices = (int)SvIV(ST(3))
;
	Color	color;

	if (sv_derived_from(ST(0), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(centerPos))
		croak("Size %d of packed data != expected %d",
			len, sizeof(centerPos));
	    centerPos = *(Vector3 *)s;
	}
	else
	    croak("centerPos is not of type Vector3")
;

	if (sv_derived_from(ST(4), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(4)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawSphereEx(centerPos, radius, rings, slices, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawSphereWires); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawSphereWires)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "centerPos, radius, rings, slices, color");
    {
	Vector3	centerPos;
	float	radius = (float)SvNV(ST(1))
;
	int	rings = (int)SvIV(ST(2))
;
	int	slices = (int)SvIV(ST(3))
;
	Color	color;

	if (sv_derived_from(ST(0), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(centerPos))
		croak("Size %d of packed data != expected %d",
			len, sizeof(centerPos));
	    centerPos = *(Vector3 *)s;
	}
	else
	    croak("centerPos is not of type Vector3")
;

	if (sv_derived_from(ST(4), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(4)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawSphereWires(centerPos, radius, rings, slices, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawText); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawText)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "text, posX, posY, fontSize, color");
    {
	const char *	text = (const char *)SvPV_nolen(ST(0))
;
	int	posX = (int)SvIV(ST(1))
;
	int	posY = (int)SvIV(ST(2))
;
	int	fontSize = (int)SvIV(ST(3))
;
	Color	color;

	if (sv_derived_from(ST(4), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(4)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawText(text, posX, posY, fontSize, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawTextEx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawTextEx)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "spriteFont, text, position, fontSize, spacing, tint");
    {
	SpriteFont	spriteFont;
	const char *	text = (const char *)SvPV_nolen(ST(1))
;
	Vector2	position;
	float	fontSize = (float)SvNV(ST(3))
;
	int	spacing = (int)SvIV(ST(4))
;
	Color	tint;

	if (sv_derived_from(ST(0), "SpriteFont")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(spriteFont))
		croak("Size %d of packed data != expected %d",
			len, sizeof(spriteFont));
	    spriteFont = *(SpriteFont *)s;
	}
	else
	    croak("spriteFont is not of type SpriteFont")
;

	if (sv_derived_from(ST(2), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(position))
		croak("Size %d of packed data != expected %d",
			len, sizeof(position));
	    position = *(Vector2 *)s;
	}
	else
	    croak("position is not of type Vector2")
;

	if (sv_derived_from(ST(5), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(5)), len);
	    if (len != sizeof(tint))
		croak("Size %d of packed data != expected %d",
			len, sizeof(tint));
	    tint = *(Color *)s;
	}
	else
	    croak("tint is not of type Color")
;

	DrawTextEx(spriteFont, text, position, fontSize, spacing, tint);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawTexture); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawTexture)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "texture, posX, posY, tint");
    {
	Texture2D	texture;
	int	posX = (int)SvIV(ST(1))
;
	int	posY = (int)SvIV(ST(2))
;
	Color	tint;

	if (sv_derived_from(ST(0), "Texture2D")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(texture))
		croak("Size %d of packed data != expected %d",
			len, sizeof(texture));
	    texture = *(Texture2D *)s;
	}
	else
	    croak("texture is not of type Texture2D")
;

	if (sv_derived_from(ST(3), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(3)), len);
	    if (len != sizeof(tint))
		croak("Size %d of packed data != expected %d",
			len, sizeof(tint));
	    tint = *(Color *)s;
	}
	else
	    croak("tint is not of type Color")
;

	DrawTexture(texture, posX, posY, tint);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawTextureEx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawTextureEx)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "texture, position, rotation, scale, tint");
    {
	Texture2D	texture;
	Vector2	position;
	float	rotation = (float)SvNV(ST(2))
;
	float	scale = (float)SvNV(ST(3))
;
	Color	tint;

	if (sv_derived_from(ST(0), "Texture2D")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(texture))
		croak("Size %d of packed data != expected %d",
			len, sizeof(texture));
	    texture = *(Texture2D *)s;
	}
	else
	    croak("texture is not of type Texture2D")
;

	if (sv_derived_from(ST(1), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(position))
		croak("Size %d of packed data != expected %d",
			len, sizeof(position));
	    position = *(Vector2 *)s;
	}
	else
	    croak("position is not of type Vector2")
;

	if (sv_derived_from(ST(4), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(4)), len);
	    if (len != sizeof(tint))
		croak("Size %d of packed data != expected %d",
			len, sizeof(tint));
	    tint = *(Color *)s;
	}
	else
	    croak("tint is not of type Color")
;

	DrawTextureEx(texture, position, rotation, scale, tint);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawTexturePro); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawTexturePro)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "texture, sourceRec, destRec, origin, rotation, tint");
    {
	Texture2D	texture;
	Rectangle	sourceRec;
	Rectangle	destRec;
	Vector2	origin;
	float	rotation = (float)SvNV(ST(4))
;
	Color	tint;

	if (sv_derived_from(ST(0), "Texture2D")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(texture))
		croak("Size %d of packed data != expected %d",
			len, sizeof(texture));
	    texture = *(Texture2D *)s;
	}
	else
	    croak("texture is not of type Texture2D")
;

	if (sv_derived_from(ST(1), "Rectangle")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(sourceRec))
		croak("Size %d of packed data != expected %d",
			len, sizeof(sourceRec));
	    sourceRec = *(Rectangle *)s;
	}
	else
	    croak("sourceRec is not of type Rectangle")
;

	if (sv_derived_from(ST(2), "Rectangle")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(destRec))
		croak("Size %d of packed data != expected %d",
			len, sizeof(destRec));
	    destRec = *(Rectangle *)s;
	}
	else
	    croak("destRec is not of type Rectangle")
;

	if (sv_derived_from(ST(3), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(3)), len);
	    if (len != sizeof(origin))
		croak("Size %d of packed data != expected %d",
			len, sizeof(origin));
	    origin = *(Vector2 *)s;
	}
	else
	    croak("origin is not of type Vector2")
;

	if (sv_derived_from(ST(5), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(5)), len);
	    if (len != sizeof(tint))
		croak("Size %d of packed data != expected %d",
			len, sizeof(tint));
	    tint = *(Color *)s;
	}
	else
	    croak("tint is not of type Color")
;

	DrawTexturePro(texture, sourceRec, destRec, origin, rotation, tint);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawTextureRec); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawTextureRec)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "texture, sourceRec, position, tint");
    {
	Texture2D	texture;
	Rectangle	sourceRec;
	Vector2	position;
	Color	tint;

	if (sv_derived_from(ST(0), "Texture2D")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(texture))
		croak("Size %d of packed data != expected %d",
			len, sizeof(texture));
	    texture = *(Texture2D *)s;
	}
	else
	    croak("texture is not of type Texture2D")
;

	if (sv_derived_from(ST(1), "Rectangle")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(sourceRec))
		croak("Size %d of packed data != expected %d",
			len, sizeof(sourceRec));
	    sourceRec = *(Rectangle *)s;
	}
	else
	    croak("sourceRec is not of type Rectangle")
;

	if (sv_derived_from(ST(2), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(position))
		croak("Size %d of packed data != expected %d",
			len, sizeof(position));
	    position = *(Vector2 *)s;
	}
	else
	    croak("position is not of type Vector2")
;

	if (sv_derived_from(ST(3), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(3)), len);
	    if (len != sizeof(tint))
		croak("Size %d of packed data != expected %d",
			len, sizeof(tint));
	    tint = *(Color *)s;
	}
	else
	    croak("tint is not of type Color")
;

	DrawTextureRec(texture, sourceRec, position, tint);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawTextureV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawTextureV)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "texture, position, tint");
    {
	Texture2D	texture;
	Vector2	position;
	Color	tint;

	if (sv_derived_from(ST(0), "Texture2D")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(texture))
		croak("Size %d of packed data != expected %d",
			len, sizeof(texture));
	    texture = *(Texture2D *)s;
	}
	else
	    croak("texture is not of type Texture2D")
;

	if (sv_derived_from(ST(1), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(position))
		croak("Size %d of packed data != expected %d",
			len, sizeof(position));
	    position = *(Vector2 *)s;
	}
	else
	    croak("position is not of type Vector2")
;

	if (sv_derived_from(ST(2), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(tint))
		croak("Size %d of packed data != expected %d",
			len, sizeof(tint));
	    tint = *(Color *)s;
	}
	else
	    croak("tint is not of type Color")
;

	DrawTextureV(texture, position, tint);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawTriangle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawTriangle)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "v1, v2, v3, color");
    {
	Vector2	v1;
	Vector2	v2;
	Vector2	v3;
	Color	color;

	if (sv_derived_from(ST(0), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(v1))
		croak("Size %d of packed data != expected %d",
			len, sizeof(v1));
	    v1 = *(Vector2 *)s;
	}
	else
	    croak("v1 is not of type Vector2")
;

	if (sv_derived_from(ST(1), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(v2))
		croak("Size %d of packed data != expected %d",
			len, sizeof(v2));
	    v2 = *(Vector2 *)s;
	}
	else
	    croak("v2 is not of type Vector2")
;

	if (sv_derived_from(ST(2), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(v3))
		croak("Size %d of packed data != expected %d",
			len, sizeof(v3));
	    v3 = *(Vector2 *)s;
	}
	else
	    croak("v3 is not of type Vector2")
;

	if (sv_derived_from(ST(3), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(3)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawTriangle(v1, v2, v3, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_DrawTriangleLines); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_DrawTriangleLines)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "v1, v2, v3, color");
    {
	Vector2	v1;
	Vector2	v2;
	Vector2	v3;
	Color	color;

	if (sv_derived_from(ST(0), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(v1))
		croak("Size %d of packed data != expected %d",
			len, sizeof(v1));
	    v1 = *(Vector2 *)s;
	}
	else
	    croak("v1 is not of type Vector2")
;

	if (sv_derived_from(ST(1), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(v2))
		croak("Size %d of packed data != expected %d",
			len, sizeof(v2));
	    v2 = *(Vector2 *)s;
	}
	else
	    croak("v2 is not of type Vector2")
;

	if (sv_derived_from(ST(2), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(v3))
		croak("Size %d of packed data != expected %d",
			len, sizeof(v3));
	    v3 = *(Vector2 *)s;
	}
	else
	    croak("v3 is not of type Vector2")
;

	if (sv_derived_from(ST(3), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(3)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	DrawTriangleLines(v1, v2, v3, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_EnableCursor); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_EnableCursor)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	EnableCursor();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_End2dMode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_End2dMode)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	End2dMode();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_End3dMode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_End3dMode)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	End3dMode();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_EndBlendMode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_EndBlendMode)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	EndBlendMode();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_EndDrawing); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_EndDrawing)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	EndDrawing();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_EndShaderMode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_EndShaderMode)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	EndShaderMode();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_EndTextureMode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_EndTextureMode)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	EndTextureMode();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_Fade); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_Fade)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "color, alpha");
    {
	Color	color;
	float	alpha = (float)SvNV(ST(1))
;
	Color	RETVAL;

	if (sv_derived_from(ST(0), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	RETVAL = Fade(color, alpha);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Color", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_FormatText); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_FormatText)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "text, ...");
    {
	const char *	text = (const char *)SvPV_nolen(ST(0))
;
	const char *	RETVAL;
	dXSTARG;

	RETVAL = FormatText(text);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GenTextureMipmaps); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GenTextureMipmaps)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "texture");
    {
	Texture2D *	texture;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Texture2DPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    texture = INT2PTR(Texture2D *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::GenTextureMipmaps",
			"texture", "Texture2DPtr")
;

	GenTextureMipmaps(texture);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetCameraMatrix); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetCameraMatrix)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "camera");
    {
	Camera	camera;
	Matrix	RETVAL;

	if (sv_derived_from(ST(0), "Camera")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(camera))
		croak("Size %d of packed data != expected %d",
			len, sizeof(camera));
	    camera = *(Camera *)s;
	}
	else
	    croak("camera is not of type Camera")
;

	RETVAL = GetCameraMatrix(camera);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Matrix", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetCollisionRec); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetCollisionRec)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "rec1, rec2");
    {
	Rectangle	rec1;
	Rectangle	rec2;
	Rectangle	RETVAL;

	if (sv_derived_from(ST(0), "Rectangle")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(rec1))
		croak("Size %d of packed data != expected %d",
			len, sizeof(rec1));
	    rec1 = *(Rectangle *)s;
	}
	else
	    croak("rec1 is not of type Rectangle")
;

	if (sv_derived_from(ST(1), "Rectangle")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(rec2))
		croak("Size %d of packed data != expected %d",
			len, sizeof(rec2));
	    rec2 = *(Rectangle *)s;
	}
	else
	    croak("rec2 is not of type Rectangle")
;

	RETVAL = GetCollisionRec(rec1, rec2);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Rectangle", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetColor); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetColor)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "hexValue");
    {
	int	hexValue = (int)SvIV(ST(0))
;
	Color	RETVAL;

	RETVAL = GetColor(hexValue);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Color", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetDefaultFont); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetDefaultFont)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SpriteFont	RETVAL;

	RETVAL = GetDefaultFont();
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "SpriteFont", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetDefaultShader); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetDefaultShader)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	Shader	RETVAL;

	RETVAL = GetDefaultShader();
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Shader", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetDefaultTexture); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetDefaultTexture)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	Texture2D	RETVAL;

	RETVAL = GetDefaultTexture();
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Texture2D", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetFPS); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetFPS)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	float	RETVAL;
	dXSTARG;

	RETVAL = GetFPS();
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetFrameTime); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetFrameTime)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	float	RETVAL;
	dXSTARG;

	RETVAL = GetFrameTime();
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetGamepadAxisCount); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetGamepadAxisCount)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "gamepad");
    {
	int	gamepad = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = GetGamepadAxisCount(gamepad);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetGamepadAxisMovement); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetGamepadAxisMovement)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "gamepad, axis");
    {
	int	gamepad = (int)SvIV(ST(0))
;
	int	axis = (int)SvIV(ST(1))
;
	float	RETVAL;
	dXSTARG;

	RETVAL = GetGamepadAxisMovement(gamepad, axis);
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetGamepadButtonPressed); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetGamepadButtonPressed)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = GetGamepadButtonPressed();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetGamepadName); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetGamepadName)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "gamepad");
    {
	int	gamepad = (int)SvIV(ST(0))
;
	const char *	RETVAL;
	dXSTARG;

	RETVAL = GetGamepadName(gamepad);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetGestureDetected); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetGestureDetected)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = GetGestureDetected();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetGestureDragAngle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetGestureDragAngle)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	float	RETVAL;
	dXSTARG;

	RETVAL = GetGestureDragAngle();
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetGestureDragVector); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetGestureDragVector)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	Vector2	RETVAL;

	RETVAL = GetGestureDragVector();
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Vector2", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetGestureHoldDuration); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetGestureHoldDuration)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	float	RETVAL;
	dXSTARG;

	RETVAL = GetGestureHoldDuration();
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetGesturePinchAngle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetGesturePinchAngle)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	float	RETVAL;
	dXSTARG;

	RETVAL = GetGesturePinchAngle();
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetGesturePinchVector); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetGesturePinchVector)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	Vector2	RETVAL;

	RETVAL = GetGesturePinchVector();
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Vector2", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetHexValue); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetHexValue)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "color");
    {
	Color	color;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	RETVAL = GetHexValue(color);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetImageData); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetImageData)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "image");
    {
	Image	image;
	Color *	RETVAL;

	if (sv_derived_from(ST(0), "Image")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(image))
		croak("Size %d of packed data != expected %d",
			len, sizeof(image));
	    image = *(Image *)s;
	}
	else
	    croak("image is not of type Image")
;

	RETVAL = GetImageData(image);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "ColorPtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetKeyPressed); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetKeyPressed)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = GetKeyPressed();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetMousePosition); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetMousePosition)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	Vector2	RETVAL;

	RETVAL = GetMousePosition();
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Vector2", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetMouseRay); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetMouseRay)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "mousePosition, camera");
    {
	Vector2	mousePosition;
	Camera	camera;
	Ray	RETVAL;

	if (sv_derived_from(ST(0), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(mousePosition))
		croak("Size %d of packed data != expected %d",
			len, sizeof(mousePosition));
	    mousePosition = *(Vector2 *)s;
	}
	else
	    croak("mousePosition is not of type Vector2")
;

	if (sv_derived_from(ST(1), "Camera")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(camera))
		croak("Size %d of packed data != expected %d",
			len, sizeof(camera));
	    camera = *(Camera *)s;
	}
	else
	    croak("camera is not of type Camera")
;

	RETVAL = GetMouseRay(mousePosition, camera);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Ray", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetMouseWheelMove); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetMouseWheelMove)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = GetMouseWheelMove();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetMouseX); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetMouseX)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = GetMouseX();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetMouseY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetMouseY)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = GetMouseY();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetMusicTimeLength); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetMusicTimeLength)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "music");
    {
	Music	music;
	float	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Music")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    music = INT2PTR(Music,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::GetMusicTimeLength",
			"music", "Music")
;

	RETVAL = GetMusicTimeLength(music);
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetMusicTimePlayed); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetMusicTimePlayed)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "music");
    {
	Music	music;
	float	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Music")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    music = INT2PTR(Music,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::GetMusicTimePlayed",
			"music", "Music")
;

	RETVAL = GetMusicTimePlayed(music);
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetRandomValue); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetRandomValue)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "min, max");
    {
	int	min = (int)SvIV(ST(0))
;
	int	max = (int)SvIV(ST(1))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = GetRandomValue(min, max);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetScreenHeight); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetScreenHeight)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = GetScreenHeight();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetScreenWidth); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetScreenWidth)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = GetScreenWidth();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetShaderLocation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetShaderLocation)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "shader, uniformName");
    {
	Shader	shader;
	const char *	uniformName = (const char *)SvPV_nolen(ST(1))
;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Shader")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(shader))
		croak("Size %d of packed data != expected %d",
			len, sizeof(shader));
	    shader = *(Shader *)s;
	}
	else
	    croak("shader is not of type Shader")
;

	RETVAL = GetShaderLocation(shader, uniformName);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetStandardShader); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetStandardShader)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	Shader	RETVAL;

	RETVAL = GetStandardShader();
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Shader", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetTextureData); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetTextureData)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "texture");
    {
	Texture2D	texture;
	Image	RETVAL;

	if (sv_derived_from(ST(0), "Texture2D")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(texture))
		croak("Size %d of packed data != expected %d",
			len, sizeof(texture));
	    texture = *(Texture2D *)s;
	}
	else
	    croak("texture is not of type Texture2D")
;

	RETVAL = GetTextureData(texture);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Image", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetTouchPointsCount); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetTouchPointsCount)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = GetTouchPointsCount();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetTouchPosition); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetTouchPosition)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "index");
    {
	int	index = (int)SvIV(ST(0))
;
	Vector2	RETVAL;

	RETVAL = GetTouchPosition(index);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Vector2", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetTouchX); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetTouchX)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = GetTouchX();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetTouchY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetTouchY)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = GetTouchY();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetWaveData); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetWaveData)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "wave");
    {
	Wave	wave;
	float *	RETVAL;

	if (sv_derived_from(ST(0), "Wave")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(wave))
		croak("Size %d of packed data != expected %d",
			len, sizeof(wave));
	    wave = *(Wave *)s;
	}
	else
	    croak("wave is not of type Wave")
;

	RETVAL = GetWaveData(wave);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "floatPtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_GetWorldToScreen); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_GetWorldToScreen)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "position, camera");
    {
	Vector3	position;
	Camera	camera;
	Vector2	RETVAL;

	if (sv_derived_from(ST(0), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(position))
		croak("Size %d of packed data != expected %d",
			len, sizeof(position));
	    position = *(Vector3 *)s;
	}
	else
	    croak("position is not of type Vector3")
;

	if (sv_derived_from(ST(1), "Camera")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(camera))
		croak("Size %d of packed data != expected %d",
			len, sizeof(camera));
	    camera = *(Camera *)s;
	}
	else
	    croak("camera is not of type Camera")
;

	RETVAL = GetWorldToScreen(position, camera);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Vector2", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_HideCursor); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_HideCursor)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	HideCursor();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_ImageAlphaMask); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ImageAlphaMask)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "image, alphaMask");
    {
	Image *	image;
	Image	alphaMask;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(Image *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::ImageAlphaMask",
			"image", "ImagePtr")
;

	if (sv_derived_from(ST(1), "Image")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(alphaMask))
		croak("Size %d of packed data != expected %d",
			len, sizeof(alphaMask));
	    alphaMask = *(Image *)s;
	}
	else
	    croak("alphaMask is not of type Image")
;

	ImageAlphaMask(image, alphaMask);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_ImageColorBrightness); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ImageColorBrightness)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "image, brightness");
    {
	Image *	image;
	int	brightness = (int)SvIV(ST(1))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(Image *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::ImageColorBrightness",
			"image", "ImagePtr")
;

	ImageColorBrightness(image, brightness);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_ImageColorContrast); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ImageColorContrast)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "image, contrast");
    {
	Image *	image;
	float	contrast = (float)SvNV(ST(1))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(Image *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::ImageColorContrast",
			"image", "ImagePtr")
;

	ImageColorContrast(image, contrast);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_ImageColorGrayscale); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ImageColorGrayscale)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "image");
    {
	Image *	image;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(Image *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::ImageColorGrayscale",
			"image", "ImagePtr")
;

	ImageColorGrayscale(image);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_ImageColorInvert); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ImageColorInvert)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "image");
    {
	Image *	image;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(Image *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::ImageColorInvert",
			"image", "ImagePtr")
;

	ImageColorInvert(image);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_ImageColorTint); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ImageColorTint)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "image, color");
    {
	Image *	image;
	Color	color;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(Image *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::ImageColorTint",
			"image", "ImagePtr")
;

	if (sv_derived_from(ST(1), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	ImageColorTint(image, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_ImageCopy); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ImageCopy)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "image");
    {
	Image	image;
	Image	RETVAL;

	if (sv_derived_from(ST(0), "Image")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(image))
		croak("Size %d of packed data != expected %d",
			len, sizeof(image));
	    image = *(Image *)s;
	}
	else
	    croak("image is not of type Image")
;

	RETVAL = ImageCopy(image);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Image", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_ImageCrop); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ImageCrop)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "image, crop");
    {
	Image *	image;
	Rectangle	crop;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(Image *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::ImageCrop",
			"image", "ImagePtr")
;

	if (sv_derived_from(ST(1), "Rectangle")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(crop))
		croak("Size %d of packed data != expected %d",
			len, sizeof(crop));
	    crop = *(Rectangle *)s;
	}
	else
	    croak("crop is not of type Rectangle")
;

	ImageCrop(image, crop);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_ImageDither); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ImageDither)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "image, rBpp, gBpp, bBpp, aBpp");
    {
	Image *	image;
	int	rBpp = (int)SvIV(ST(1))
;
	int	gBpp = (int)SvIV(ST(2))
;
	int	bBpp = (int)SvIV(ST(3))
;
	int	aBpp = (int)SvIV(ST(4))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(Image *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::ImageDither",
			"image", "ImagePtr")
;

	ImageDither(image, rBpp, gBpp, bBpp, aBpp);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_ImageDraw); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ImageDraw)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "dst, src, srcRec, dstRec");
    {
	Image *	dst;
	Image	src;
	Rectangle	srcRec;
	Rectangle	dstRec;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dst = INT2PTR(Image *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::ImageDraw",
			"dst", "ImagePtr")
;

	if (sv_derived_from(ST(1), "Image")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(src))
		croak("Size %d of packed data != expected %d",
			len, sizeof(src));
	    src = *(Image *)s;
	}
	else
	    croak("src is not of type Image")
;

	if (sv_derived_from(ST(2), "Rectangle")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(srcRec))
		croak("Size %d of packed data != expected %d",
			len, sizeof(srcRec));
	    srcRec = *(Rectangle *)s;
	}
	else
	    croak("srcRec is not of type Rectangle")
;

	if (sv_derived_from(ST(3), "Rectangle")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(3)), len);
	    if (len != sizeof(dstRec))
		croak("Size %d of packed data != expected %d",
			len, sizeof(dstRec));
	    dstRec = *(Rectangle *)s;
	}
	else
	    croak("dstRec is not of type Rectangle")
;

	ImageDraw(dst, src, srcRec, dstRec);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_ImageDrawText); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ImageDrawText)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "dst, position, text, fontSize, color");
    {
	Image *	dst;
	Vector2	position;
	const char *	text = (const char *)SvPV_nolen(ST(2))
;
	int	fontSize = (int)SvIV(ST(3))
;
	Color	color;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dst = INT2PTR(Image *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::ImageDrawText",
			"dst", "ImagePtr")
;

	if (sv_derived_from(ST(1), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(position))
		croak("Size %d of packed data != expected %d",
			len, sizeof(position));
	    position = *(Vector2 *)s;
	}
	else
	    croak("position is not of type Vector2")
;

	if (sv_derived_from(ST(4), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(4)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	ImageDrawText(dst, position, text, fontSize, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_ImageDrawTextEx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ImageDrawTextEx)
{
    dVAR; dXSARGS;
    if (items != 7)
       croak_xs_usage(cv,  "dst, position, font, text, fontSize, spacing, color");
    {
	Image *	dst;
	Vector2	position;
	SpriteFont	font;
	const char *	text = (const char *)SvPV_nolen(ST(3))
;
	float	fontSize = (float)SvNV(ST(4))
;
	int	spacing = (int)SvIV(ST(5))
;
	Color	color;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dst = INT2PTR(Image *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::ImageDrawTextEx",
			"dst", "ImagePtr")
;

	if (sv_derived_from(ST(1), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(position))
		croak("Size %d of packed data != expected %d",
			len, sizeof(position));
	    position = *(Vector2 *)s;
	}
	else
	    croak("position is not of type Vector2")
;

	if (sv_derived_from(ST(2), "SpriteFont")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(font))
		croak("Size %d of packed data != expected %d",
			len, sizeof(font));
	    font = *(SpriteFont *)s;
	}
	else
	    croak("font is not of type SpriteFont")
;

	if (sv_derived_from(ST(6), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(6)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	ImageDrawTextEx(dst, position, font, text, fontSize, spacing, color);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_ImageFlipHorizontal); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ImageFlipHorizontal)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "image");
    {
	Image *	image;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(Image *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::ImageFlipHorizontal",
			"image", "ImagePtr")
;

	ImageFlipHorizontal(image);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_ImageFlipVertical); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ImageFlipVertical)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "image");
    {
	Image *	image;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(Image *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::ImageFlipVertical",
			"image", "ImagePtr")
;

	ImageFlipVertical(image);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_ImageFormat); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ImageFormat)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "image, newFormat");
    {
	Image *	image;
	int	newFormat = (int)SvIV(ST(1))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(Image *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::ImageFormat",
			"image", "ImagePtr")
;

	ImageFormat(image, newFormat);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_ImageResize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ImageResize)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "image, newWidth, newHeight");
    {
	Image *	image;
	int	newWidth = (int)SvIV(ST(1))
;
	int	newHeight = (int)SvIV(ST(2))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(Image *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::ImageResize",
			"image", "ImagePtr")
;

	ImageResize(image, newWidth, newHeight);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_ImageResizeNN); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ImageResizeNN)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "image, newWidth, newHeight");
    {
	Image *	image;
	int	newWidth = (int)SvIV(ST(1))
;
	int	newHeight = (int)SvIV(ST(2))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(Image *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::ImageResizeNN",
			"image", "ImagePtr")
;

	ImageResizeNN(image, newWidth, newHeight);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_ImageText); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ImageText)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "text, fontSize, color");
    {
	const char *	text = (const char *)SvPV_nolen(ST(0))
;
	int	fontSize = (int)SvIV(ST(1))
;
	Color	color;
	Image	RETVAL;

	if (sv_derived_from(ST(2), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(color))
		croak("Size %d of packed data != expected %d",
			len, sizeof(color));
	    color = *(Color *)s;
	}
	else
	    croak("color is not of type Color")
;

	RETVAL = ImageText(text, fontSize, color);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Image", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_ImageTextEx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ImageTextEx)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "font, text, fontSize, spacing, tint");
    {
	SpriteFont	font;
	const char *	text = (const char *)SvPV_nolen(ST(1))
;
	float	fontSize = (float)SvNV(ST(2))
;
	int	spacing = (int)SvIV(ST(3))
;
	Color	tint;
	Image	RETVAL;

	if (sv_derived_from(ST(0), "SpriteFont")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(font))
		croak("Size %d of packed data != expected %d",
			len, sizeof(font));
	    font = *(SpriteFont *)s;
	}
	else
	    croak("font is not of type SpriteFont")
;

	if (sv_derived_from(ST(4), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(4)), len);
	    if (len != sizeof(tint))
		croak("Size %d of packed data != expected %d",
			len, sizeof(tint));
	    tint = *(Color *)s;
	}
	else
	    croak("tint is not of type Color")
;

	RETVAL = ImageTextEx(font, text, fontSize, spacing, tint);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Image", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_ImageToPOT); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ImageToPOT)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "image, fillColor");
    {
	Image *	image;
	Color	fillColor;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(Image *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::ImageToPOT",
			"image", "ImagePtr")
;

	if (sv_derived_from(ST(1), "Color")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(fillColor))
		croak("Size %d of packed data != expected %d",
			len, sizeof(fillColor));
	    fillColor = *(Color *)s;
	}
	else
	    croak("fillColor is not of type Color")
;

	ImageToPOT(image, fillColor);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_InitAudioDevice); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_InitAudioDevice)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	InitAudioDevice();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_InitAudioStream); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_InitAudioStream)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "sampleRate, sampleSize, channels");
    {
	unsigned int	sampleRate = (unsigned int)SvUV(ST(0))
;
	unsigned int	sampleSize = (unsigned int)SvUV(ST(1))
;
	unsigned int	channels = (unsigned int)SvUV(ST(2))
;
	AudioStream	RETVAL;

	RETVAL = InitAudioStream(sampleRate, sampleSize, channels);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "AudioStream", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_InitVrDevice); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_InitVrDevice)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "vdDevice");
    {
	int	vdDevice = (int)SvIV(ST(0))
;

	InitVrDevice(vdDevice);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_InitWindow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_InitWindow)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "width, height, title");
    {
	int	width = (int)SvIV(ST(0))
;
	int	height = (int)SvIV(ST(1))
;
	const char *	title = (const char *)SvPV_nolen(ST(2))
;

	InitWindow(width, height, title);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_IsAudioBufferProcessed); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_IsAudioBufferProcessed)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "stream");
    {
	AudioStream	stream;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "AudioStream")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(stream))
		croak("Size %d of packed data != expected %d",
			len, sizeof(stream));
	    stream = *(AudioStream *)s;
	}
	else
	    croak("stream is not of type AudioStream")
;

	RETVAL = IsAudioBufferProcessed(stream);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_IsAudioDeviceReady); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_IsAudioDeviceReady)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = IsAudioDeviceReady();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_IsCursorHidden); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_IsCursorHidden)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = IsCursorHidden();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_IsFileDropped); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_IsFileDropped)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = IsFileDropped();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_IsGamepadAvailable); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_IsGamepadAvailable)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "gamepad");
    {
	int	gamepad = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = IsGamepadAvailable(gamepad);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_IsGamepadButtonDown); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_IsGamepadButtonDown)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "gamepad, button");
    {
	int	gamepad = (int)SvIV(ST(0))
;
	int	button = (int)SvIV(ST(1))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = IsGamepadButtonDown(gamepad, button);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_IsGamepadButtonPressed); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_IsGamepadButtonPressed)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "gamepad, button");
    {
	int	gamepad = (int)SvIV(ST(0))
;
	int	button = (int)SvIV(ST(1))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = IsGamepadButtonPressed(gamepad, button);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_IsGamepadButtonReleased); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_IsGamepadButtonReleased)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "gamepad, button");
    {
	int	gamepad = (int)SvIV(ST(0))
;
	int	button = (int)SvIV(ST(1))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = IsGamepadButtonReleased(gamepad, button);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_IsGamepadButtonUp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_IsGamepadButtonUp)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "gamepad, button");
    {
	int	gamepad = (int)SvIV(ST(0))
;
	int	button = (int)SvIV(ST(1))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = IsGamepadButtonUp(gamepad, button);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_IsGamepadName); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_IsGamepadName)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "gamepad, name");
    {
	int	gamepad = (int)SvIV(ST(0))
;
	const char *	name = (const char *)SvPV_nolen(ST(1))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = IsGamepadName(gamepad, name);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_IsGestureDetected); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_IsGestureDetected)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "gesture");
    {
	int	gesture = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = IsGestureDetected(gesture);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_IsKeyDown); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_IsKeyDown)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "key");
    {
	int	key = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = IsKeyDown(key);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_IsKeyPressed); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_IsKeyPressed)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "key");
    {
	int	key = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = IsKeyPressed(key);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_IsKeyReleased); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_IsKeyReleased)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "key");
    {
	int	key = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = IsKeyReleased(key);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_IsKeyUp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_IsKeyUp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "key");
    {
	int	key = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = IsKeyUp(key);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_IsMouseButtonDown); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_IsMouseButtonDown)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "button");
    {
	int	button = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = IsMouseButtonDown(button);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_IsMouseButtonPressed); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_IsMouseButtonPressed)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "button");
    {
	int	button = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = IsMouseButtonPressed(button);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_IsMouseButtonReleased); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_IsMouseButtonReleased)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "button");
    {
	int	button = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = IsMouseButtonReleased(button);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_IsMouseButtonUp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_IsMouseButtonUp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "button");
    {
	int	button = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = IsMouseButtonUp(button);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_IsMusicPlaying); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_IsMusicPlaying)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "music");
    {
	Music	music;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Music")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    music = INT2PTR(Music,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::IsMusicPlaying",
			"music", "Music")
;

	RETVAL = IsMusicPlaying(music);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_IsSoundPlaying); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_IsSoundPlaying)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sound");
    {
	Sound	sound;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Sound")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(sound))
		croak("Size %d of packed data != expected %d",
			len, sizeof(sound));
	    sound = *(Sound *)s;
	}
	else
	    croak("sound is not of type Sound")
;

	RETVAL = IsSoundPlaying(sound);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_IsVrDeviceReady); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_IsVrDeviceReady)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = IsVrDeviceReady();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_IsVrSimulator); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_IsVrSimulator)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = IsVrSimulator();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_IsWindowMinimized); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_IsWindowMinimized)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = IsWindowMinimized();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_LoadCubicmap); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_LoadCubicmap)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cubicmap");
    {
	Image	cubicmap;
	Model	RETVAL;

	if (sv_derived_from(ST(0), "Image")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(cubicmap))
		croak("Size %d of packed data != expected %d",
			len, sizeof(cubicmap));
	    cubicmap = *(Image *)s;
	}
	else
	    croak("cubicmap is not of type Image")
;

	RETVAL = LoadCubicmap(cubicmap);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Model", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_LoadDefaultMaterial); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_LoadDefaultMaterial)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	Material	RETVAL;

	RETVAL = LoadDefaultMaterial();
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Material", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_LoadHeightmap); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_LoadHeightmap)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "heightmap, size");
    {
	Image	heightmap;
	Vector3	size;
	Model	RETVAL;

	if (sv_derived_from(ST(0), "Image")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(heightmap))
		croak("Size %d of packed data != expected %d",
			len, sizeof(heightmap));
	    heightmap = *(Image *)s;
	}
	else
	    croak("heightmap is not of type Image")
;

	if (sv_derived_from(ST(1), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(1)), len);
	    if (len != sizeof(size))
		croak("Size %d of packed data != expected %d",
			len, sizeof(size));
	    size = *(Vector3 *)s;
	}
	else
	    croak("size is not of type Vector3")
;

	RETVAL = LoadHeightmap(heightmap, size);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Model", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_LoadImage); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_LoadImage)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fileName");
    {
	const char *	fileName = (const char *)SvPV_nolen(ST(0))
;
	Image	RETVAL;

	RETVAL = LoadImage(fileName);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Image", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_LoadImageEx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_LoadImageEx)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "pixels, width, height");
    {
	Color *	pixels;
	int	width = (int)SvIV(ST(1))
;
	int	height = (int)SvIV(ST(2))
;
	Image	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ColorPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pixels = INT2PTR(Color *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::LoadImageEx",
			"pixels", "ColorPtr")
;

	RETVAL = LoadImageEx(pixels, width, height);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Image", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_LoadImageFromRES); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_LoadImageFromRES)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "rresName, resId");
    {
	const char *	rresName = (const char *)SvPV_nolen(ST(0))
;
	int	resId = (int)SvIV(ST(1))
;
	Image	RETVAL;

	RETVAL = LoadImageFromRES(rresName, resId);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Image", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_LoadImageRaw); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_LoadImageRaw)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "fileName, width, height, format, headerSize");
    {
	const char *	fileName = (const char *)SvPV_nolen(ST(0))
;
	int	width = (int)SvIV(ST(1))
;
	int	height = (int)SvIV(ST(2))
;
	int	format = (int)SvIV(ST(3))
;
	int	headerSize = (int)SvIV(ST(4))
;
	Image	RETVAL;

	RETVAL = LoadImageRaw(fileName, width, height, format, headerSize);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Image", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_LoadMaterial); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_LoadMaterial)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fileName");
    {
	const char *	fileName = (const char *)SvPV_nolen(ST(0))
;
	Material	RETVAL;

	RETVAL = LoadMaterial(fileName);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Material", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_LoadModel); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_LoadModel)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fileName");
    {
	const char *	fileName = (const char *)SvPV_nolen(ST(0))
;
	Model	RETVAL;

	RETVAL = LoadModel(fileName);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Model", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_LoadModelEx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_LoadModelEx)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "data, dynamic");
    {
	Mesh	data;
	int	dynamic = (int)SvIV(ST(1))
;
	Model	RETVAL;

	if (sv_derived_from(ST(0), "Mesh")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(data))
		croak("Size %d of packed data != expected %d",
			len, sizeof(data));
	    data = *(Mesh *)s;
	}
	else
	    croak("data is not of type Mesh")
;

	RETVAL = LoadModelEx(data, dynamic);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Model", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_LoadModelFromRES); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_LoadModelFromRES)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "rresName, resId");
    {
	const char *	rresName = (const char *)SvPV_nolen(ST(0))
;
	int	resId = (int)SvIV(ST(1))
;
	Model	RETVAL;

	RETVAL = LoadModelFromRES(rresName, resId);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Model", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_LoadMusicStream); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_LoadMusicStream)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fileName");
    {
	const char *	fileName = (const char *)SvPV_nolen(ST(0))
;
	Music	RETVAL;

	RETVAL = LoadMusicStream(fileName);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Music", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_LoadRenderTexture); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_LoadRenderTexture)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "width, height");
    {
	int	width = (int)SvIV(ST(0))
;
	int	height = (int)SvIV(ST(1))
;
	RenderTexture2D	RETVAL;

	RETVAL = LoadRenderTexture(width, height);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "RenderTexture2D", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_LoadShader); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_LoadShader)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "vsFileName, fsFileName");
    {
	char *	vsFileName = (char *)SvPV_nolen(ST(0))
;
	char *	fsFileName = (char *)SvPV_nolen(ST(1))
;
	Shader	RETVAL;

	RETVAL = LoadShader(vsFileName, fsFileName);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Shader", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_LoadSound); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_LoadSound)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fileName");
    {
	const char *	fileName = (const char *)SvPV_nolen(ST(0))
;
	Sound	RETVAL;

	RETVAL = LoadSound(fileName);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Sound", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_LoadSoundFromRES); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_LoadSoundFromRES)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "rresName, resId");
    {
	const char *	rresName = (const char *)SvPV_nolen(ST(0))
;
	int	resId = (int)SvIV(ST(1))
;
	Sound	RETVAL;

	RETVAL = LoadSoundFromRES(rresName, resId);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Sound", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_LoadSoundFromWave); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_LoadSoundFromWave)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "wave");
    {
	Wave	wave;
	Sound	RETVAL;

	if (sv_derived_from(ST(0), "Wave")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(wave))
		croak("Size %d of packed data != expected %d",
			len, sizeof(wave));
	    wave = *(Wave *)s;
	}
	else
	    croak("wave is not of type Wave")
;

	RETVAL = LoadSoundFromWave(wave);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Sound", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_LoadSpriteFont); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_LoadSpriteFont)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fileName");
    {
	const char *	fileName = (const char *)SvPV_nolen(ST(0))
;
	SpriteFont	RETVAL;

	RETVAL = LoadSpriteFont(fileName);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "SpriteFont", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_LoadSpriteFontTTF); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_LoadSpriteFontTTF)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "fileName, fontSize, numChars, fontChars");
    {
	const char *	fileName = (const char *)SvPV_nolen(ST(0))
;
	int	fontSize = (int)SvIV(ST(1))
;
	int	numChars = (int)SvIV(ST(2))
;
	int *	fontChars;
	SpriteFont	RETVAL;

	if (SvROK(ST(3)) && sv_derived_from(ST(3), "intPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(3)));
	    fontChars = INT2PTR(int *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::LoadSpriteFontTTF",
			"fontChars", "intPtr")
;

	RETVAL = LoadSpriteFontTTF(fileName, fontSize, numChars, fontChars);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "SpriteFont", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_LoadStandardMaterial); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_LoadStandardMaterial)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	Material	RETVAL;

	RETVAL = LoadStandardMaterial();
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Material", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_LoadTexture); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_LoadTexture)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fileName");
    {
	const char *	fileName = (const char *)SvPV_nolen(ST(0))
;
	Texture2D	RETVAL;

	RETVAL = LoadTexture(fileName);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Texture2D", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_LoadTextureEx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_LoadTextureEx)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "data, width, height, textureFormat");
    {
	void *	data = INT2PTR(void *,SvIV(ST(0)))
;
	int	width = (int)SvIV(ST(1))
;
	int	height = (int)SvIV(ST(2))
;
	int	textureFormat = (int)SvIV(ST(3))
;
	Texture2D	RETVAL;

	RETVAL = LoadTextureEx(data, width, height, textureFormat);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Texture2D", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_LoadTextureFromImage); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_LoadTextureFromImage)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "image");
    {
	Image	image;
	Texture2D	RETVAL;

	if (sv_derived_from(ST(0), "Image")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(image))
		croak("Size %d of packed data != expected %d",
			len, sizeof(image));
	    image = *(Image *)s;
	}
	else
	    croak("image is not of type Image")
;

	RETVAL = LoadTextureFromImage(image);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Texture2D", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_LoadTextureFromRES); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_LoadTextureFromRES)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "rresName, resId");
    {
	const char *	rresName = (const char *)SvPV_nolen(ST(0))
;
	int	resId = (int)SvIV(ST(1))
;
	Texture2D	RETVAL;

	RETVAL = LoadTextureFromRES(rresName, resId);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Texture2D", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_LoadWave); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_LoadWave)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fileName");
    {
	const char *	fileName = (const char *)SvPV_nolen(ST(0))
;
	Wave	RETVAL;

	RETVAL = LoadWave(fileName);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Wave", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_LoadWaveEx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_LoadWaveEx)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "data, sampleCount, sampleRate, sampleSize, channels");
    {
	float *	data;
	int	sampleCount = (int)SvIV(ST(1))
;
	int	sampleRate = (int)SvIV(ST(2))
;
	int	sampleSize = (int)SvIV(ST(3))
;
	int	channels = (int)SvIV(ST(4))
;
	Wave	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "floatPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    data = INT2PTR(float *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::LoadWaveEx",
			"data", "floatPtr")
;

	RETVAL = LoadWaveEx(data, sampleCount, sampleRate, sampleSize, channels);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Wave", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_MatrixToFloat); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_MatrixToFloat)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "mat");
    {
	Matrix	mat;
	float *	RETVAL;

	if (sv_derived_from(ST(0), "Matrix")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(mat))
		croak("Size %d of packed data != expected %d",
			len, sizeof(mat));
	    mat = *(Matrix *)s;
	}
	else
	    croak("mat is not of type Matrix")
;

	RETVAL = MatrixToFloat(mat);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "floatPtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_MeasureText); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_MeasureText)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "text, fontSize");
    {
	const char *	text = (const char *)SvPV_nolen(ST(0))
;
	int	fontSize = (int)SvIV(ST(1))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = MeasureText(text, fontSize);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_MeasureTextEx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_MeasureTextEx)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "spriteFont, text, fontSize, spacing");
    {
	SpriteFont	spriteFont;
	const char *	text = (const char *)SvPV_nolen(ST(1))
;
	float	fontSize = (float)SvNV(ST(2))
;
	int	spacing = (int)SvIV(ST(3))
;
	Vector2	RETVAL;

	if (sv_derived_from(ST(0), "SpriteFont")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(spriteFont))
		croak("Size %d of packed data != expected %d",
			len, sizeof(spriteFont));
	    spriteFont = *(SpriteFont *)s;
	}
	else
	    croak("spriteFont is not of type SpriteFont")
;

	RETVAL = MeasureTextEx(spriteFont, text, fontSize, spacing);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Vector2", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_PauseAudioStream); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_PauseAudioStream)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "stream");
    {
	AudioStream	stream;

	if (sv_derived_from(ST(0), "AudioStream")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(stream))
		croak("Size %d of packed data != expected %d",
			len, sizeof(stream));
	    stream = *(AudioStream *)s;
	}
	else
	    croak("stream is not of type AudioStream")
;

	PauseAudioStream(stream);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_PauseMusicStream); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_PauseMusicStream)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "music");
    {
	Music	music;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Music")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    music = INT2PTR(Music,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::PauseMusicStream",
			"music", "Music")
;

	PauseMusicStream(music);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_PauseSound); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_PauseSound)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sound");
    {
	Sound	sound;

	if (sv_derived_from(ST(0), "Sound")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(sound))
		croak("Size %d of packed data != expected %d",
			len, sizeof(sound));
	    sound = *(Sound *)s;
	}
	else
	    croak("sound is not of type Sound")
;

	PauseSound(sound);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_PlayAudioStream); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_PlayAudioStream)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "stream");
    {
	AudioStream	stream;

	if (sv_derived_from(ST(0), "AudioStream")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(stream))
		croak("Size %d of packed data != expected %d",
			len, sizeof(stream));
	    stream = *(AudioStream *)s;
	}
	else
	    croak("stream is not of type AudioStream")
;

	PlayAudioStream(stream);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_PlayMusicStream); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_PlayMusicStream)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "music");
    {
	Music	music;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Music")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    music = INT2PTR(Music,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::PlayMusicStream",
			"music", "Music")
;

	PlayMusicStream(music);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_PlaySound); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_PlaySound)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sound");
    {
	Sound	sound;

	if (sv_derived_from(ST(0), "Sound")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(sound))
		croak("Size %d of packed data != expected %d",
			len, sizeof(sound));
	    sound = *(Sound *)s;
	}
	else
	    croak("sound is not of type Sound")
;

	PlaySound(sound);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_ResumeAudioStream); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ResumeAudioStream)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "stream");
    {
	AudioStream	stream;

	if (sv_derived_from(ST(0), "AudioStream")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(stream))
		croak("Size %d of packed data != expected %d",
			len, sizeof(stream));
	    stream = *(AudioStream *)s;
	}
	else
	    croak("stream is not of type AudioStream")
;

	ResumeAudioStream(stream);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_ResumeMusicStream); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ResumeMusicStream)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "music");
    {
	Music	music;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Music")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    music = INT2PTR(Music,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::ResumeMusicStream",
			"music", "Music")
;

	ResumeMusicStream(music);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_ResumeSound); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ResumeSound)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sound");
    {
	Sound	sound;

	if (sv_derived_from(ST(0), "Sound")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(sound))
		croak("Size %d of packed data != expected %d",
			len, sizeof(sound));
	    sound = *(Sound *)s;
	}
	else
	    croak("sound is not of type Sound")
;

	ResumeSound(sound);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_SetCameraAltControl); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_SetCameraAltControl)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "altKey");
    {
	int	altKey = (int)SvIV(ST(0))
;

	SetCameraAltControl(altKey);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_SetCameraMode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_SetCameraMode)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "camera, mode");
    {
	Camera	camera;
	int	mode = (int)SvIV(ST(1))
;

	if (sv_derived_from(ST(0), "Camera")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(camera))
		croak("Size %d of packed data != expected %d",
			len, sizeof(camera));
	    camera = *(Camera *)s;
	}
	else
	    croak("camera is not of type Camera")
;

	SetCameraMode(camera, mode);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_SetCameraMoveControls); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_SetCameraMoveControls)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "frontKey, backKey, rightKey, leftKey, upKey, downKey");
    {
	int	frontKey = (int)SvIV(ST(0))
;
	int	backKey = (int)SvIV(ST(1))
;
	int	rightKey = (int)SvIV(ST(2))
;
	int	leftKey = (int)SvIV(ST(3))
;
	int	upKey = (int)SvIV(ST(4))
;
	int	downKey = (int)SvIV(ST(5))
;

	SetCameraMoveControls(frontKey, backKey, rightKey, leftKey, upKey, downKey);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_SetCameraPanControl); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_SetCameraPanControl)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "panKey");
    {
	int	panKey = (int)SvIV(ST(0))
;

	SetCameraPanControl(panKey);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_SetCameraSmoothZoomControl); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_SetCameraSmoothZoomControl)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "szKey");
    {
	int	szKey = (int)SvIV(ST(0))
;

	SetCameraSmoothZoomControl(szKey);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_SetConfigFlags); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_SetConfigFlags)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "flags");
    {
	char	flags = (char)*SvPV_nolen(ST(0))
;

	SetConfigFlags(flags);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_SetExitKey); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_SetExitKey)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "key");
    {
	int	key = (int)SvIV(ST(0))
;

	SetExitKey(key);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_SetGesturesEnabled); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_SetGesturesEnabled)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "gestureFlags");
    {
	unsigned int	gestureFlags = (unsigned int)SvUV(ST(0))
;

	SetGesturesEnabled(gestureFlags);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_SetMatrixModelview); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_SetMatrixModelview)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "view");
    {
	Matrix	view;

	if (sv_derived_from(ST(0), "Matrix")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(view))
		croak("Size %d of packed data != expected %d",
			len, sizeof(view));
	    view = *(Matrix *)s;
	}
	else
	    croak("view is not of type Matrix")
;

	SetMatrixModelview(view);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_SetMatrixProjection); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_SetMatrixProjection)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "proj");
    {
	Matrix	proj;

	if (sv_derived_from(ST(0), "Matrix")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(proj))
		croak("Size %d of packed data != expected %d",
			len, sizeof(proj));
	    proj = *(Matrix *)s;
	}
	else
	    croak("proj is not of type Matrix")
;

	SetMatrixProjection(proj);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_SetMousePosition); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_SetMousePosition)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "position");
    {
	Vector2	position;

	if (sv_derived_from(ST(0), "Vector2")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(position))
		croak("Size %d of packed data != expected %d",
			len, sizeof(position));
	    position = *(Vector2 *)s;
	}
	else
	    croak("position is not of type Vector2")
;

	SetMousePosition(position);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_SetMusicPitch); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_SetMusicPitch)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "music, pitch");
    {
	Music	music;
	float	pitch = (float)SvNV(ST(1))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Music")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    music = INT2PTR(Music,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::SetMusicPitch",
			"music", "Music")
;

	SetMusicPitch(music, pitch);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_SetMusicVolume); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_SetMusicVolume)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "music, volume");
    {
	Music	music;
	float	volume = (float)SvNV(ST(1))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Music")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    music = INT2PTR(Music,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::SetMusicVolume",
			"music", "Music")
;

	SetMusicVolume(music, volume);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_SetShaderValue); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_SetShaderValue)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "shader, uniformLoc, value, size");
    {
	Shader	shader;
	int	uniformLoc = (int)SvIV(ST(1))
;
	float *	value;
	int	size = (int)SvIV(ST(3))
;

	if (sv_derived_from(ST(0), "Shader")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(shader))
		croak("Size %d of packed data != expected %d",
			len, sizeof(shader));
	    shader = *(Shader *)s;
	}
	else
	    croak("shader is not of type Shader")
;

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "floatPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    value = INT2PTR(float *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::SetShaderValue",
			"value", "floatPtr")
;

	SetShaderValue(shader, uniformLoc, value, size);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_SetShaderValueMatrix); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_SetShaderValueMatrix)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "shader, uniformLoc, mat");
    {
	Shader	shader;
	int	uniformLoc = (int)SvIV(ST(1))
;
	Matrix	mat;

	if (sv_derived_from(ST(0), "Shader")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(shader))
		croak("Size %d of packed data != expected %d",
			len, sizeof(shader));
	    shader = *(Shader *)s;
	}
	else
	    croak("shader is not of type Shader")
;

	if (sv_derived_from(ST(2), "Matrix")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(2)), len);
	    if (len != sizeof(mat))
		croak("Size %d of packed data != expected %d",
			len, sizeof(mat));
	    mat = *(Matrix *)s;
	}
	else
	    croak("mat is not of type Matrix")
;

	SetShaderValueMatrix(shader, uniformLoc, mat);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_SetShaderValuei); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_SetShaderValuei)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "shader, uniformLoc, value, size");
    {
	Shader	shader;
	int	uniformLoc = (int)SvIV(ST(1))
;
	int *	value;
	int	size = (int)SvIV(ST(3))
;

	if (sv_derived_from(ST(0), "Shader")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(shader))
		croak("Size %d of packed data != expected %d",
			len, sizeof(shader));
	    shader = *(Shader *)s;
	}
	else
	    croak("shader is not of type Shader")
;

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "intPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    value = INT2PTR(int *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::SetShaderValuei",
			"value", "intPtr")
;

	SetShaderValuei(shader, uniformLoc, value, size);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_SetSoundPitch); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_SetSoundPitch)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "sound, pitch");
    {
	Sound	sound;
	float	pitch = (float)SvNV(ST(1))
;

	if (sv_derived_from(ST(0), "Sound")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(sound))
		croak("Size %d of packed data != expected %d",
			len, sizeof(sound));
	    sound = *(Sound *)s;
	}
	else
	    croak("sound is not of type Sound")
;

	SetSoundPitch(sound, pitch);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_SetSoundVolume); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_SetSoundVolume)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "sound, volume");
    {
	Sound	sound;
	float	volume = (float)SvNV(ST(1))
;

	if (sv_derived_from(ST(0), "Sound")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(sound))
		croak("Size %d of packed data != expected %d",
			len, sizeof(sound));
	    sound = *(Sound *)s;
	}
	else
	    croak("sound is not of type Sound")
;

	SetSoundVolume(sound, volume);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_SetTargetFPS); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_SetTargetFPS)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fps");
    {
	int	fps = (int)SvIV(ST(0))
;

	SetTargetFPS(fps);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_SetTextureFilter); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_SetTextureFilter)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "texture, filterMode");
    {
	Texture2D	texture;
	int	filterMode = (int)SvIV(ST(1))
;

	if (sv_derived_from(ST(0), "Texture2D")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(texture))
		croak("Size %d of packed data != expected %d",
			len, sizeof(texture));
	    texture = *(Texture2D *)s;
	}
	else
	    croak("texture is not of type Texture2D")
;

	SetTextureFilter(texture, filterMode);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_SetTextureWrap); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_SetTextureWrap)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "texture, wrapMode");
    {
	Texture2D	texture;
	int	wrapMode = (int)SvIV(ST(1))
;

	if (sv_derived_from(ST(0), "Texture2D")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(texture))
		croak("Size %d of packed data != expected %d",
			len, sizeof(texture));
	    texture = *(Texture2D *)s;
	}
	else
	    croak("texture is not of type Texture2D")
;

	SetTextureWrap(texture, wrapMode);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_ShowCursor); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ShowCursor)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	ShowCursor();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_ShowLogo); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ShowLogo)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	ShowLogo();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_StopAudioStream); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_StopAudioStream)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "stream");
    {
	AudioStream	stream;

	if (sv_derived_from(ST(0), "AudioStream")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(stream))
		croak("Size %d of packed data != expected %d",
			len, sizeof(stream));
	    stream = *(AudioStream *)s;
	}
	else
	    croak("stream is not of type AudioStream")
;

	StopAudioStream(stream);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_StopMusicStream); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_StopMusicStream)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "music");
    {
	Music	music;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Music")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    music = INT2PTR(Music,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::StopMusicStream",
			"music", "Music")
;

	StopMusicStream(music);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_StopSound); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_StopSound)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sound");
    {
	Sound	sound;

	if (sv_derived_from(ST(0), "Sound")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(sound))
		croak("Size %d of packed data != expected %d",
			len, sizeof(sound));
	    sound = *(Sound *)s;
	}
	else
	    croak("sound is not of type Sound")
;

	StopSound(sound);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_StorageLoadValue); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_StorageLoadValue)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "position");
    {
	int	position = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = StorageLoadValue(position);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_StorageSaveValue); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_StorageSaveValue)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "position, value");
    {
	int	position = (int)SvIV(ST(0))
;
	int	value = (int)SvIV(ST(1))
;

	StorageSaveValue(position, value);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_SubText); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_SubText)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "text, position, length");
    {
	const char *	text = (const char *)SvPV_nolen(ST(0))
;
	int	position = (int)SvIV(ST(1))
;
	int	length = (int)SvIV(ST(2))
;
	const char *	RETVAL;
	dXSTARG;

	RETVAL = SubText(text, position, length);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_ToggleFullscreen); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ToggleFullscreen)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	ToggleFullscreen();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_ToggleVrMode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_ToggleVrMode)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	ToggleVrMode();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_UnloadImage); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_UnloadImage)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "image");
    {
	Image	image;

	if (sv_derived_from(ST(0), "Image")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(image))
		croak("Size %d of packed data != expected %d",
			len, sizeof(image));
	    image = *(Image *)s;
	}
	else
	    croak("image is not of type Image")
;

	UnloadImage(image);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_UnloadMaterial); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_UnloadMaterial)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "material");
    {
	Material	material;

	if (sv_derived_from(ST(0), "Material")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(material))
		croak("Size %d of packed data != expected %d",
			len, sizeof(material));
	    material = *(Material *)s;
	}
	else
	    croak("material is not of type Material")
;

	UnloadMaterial(material);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_UnloadModel); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_UnloadModel)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "model");
    {
	Model	model;

	if (sv_derived_from(ST(0), "Model")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(model))
		croak("Size %d of packed data != expected %d",
			len, sizeof(model));
	    model = *(Model *)s;
	}
	else
	    croak("model is not of type Model")
;

	UnloadModel(model);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_UnloadMusicStream); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_UnloadMusicStream)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "music");
    {
	Music	music;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Music")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    music = INT2PTR(Music,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::UnloadMusicStream",
			"music", "Music")
;

	UnloadMusicStream(music);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_UnloadRenderTexture); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_UnloadRenderTexture)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "target");
    {
	RenderTexture2D	target;

	if (sv_derived_from(ST(0), "RenderTexture2D")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(target))
		croak("Size %d of packed data != expected %d",
			len, sizeof(target));
	    target = *(RenderTexture2D *)s;
	}
	else
	    croak("target is not of type RenderTexture2D")
;

	UnloadRenderTexture(target);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_UnloadShader); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_UnloadShader)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "shader");
    {
	Shader	shader;

	if (sv_derived_from(ST(0), "Shader")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(shader))
		croak("Size %d of packed data != expected %d",
			len, sizeof(shader));
	    shader = *(Shader *)s;
	}
	else
	    croak("shader is not of type Shader")
;

	UnloadShader(shader);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_UnloadSound); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_UnloadSound)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sound");
    {
	Sound	sound;

	if (sv_derived_from(ST(0), "Sound")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(sound))
		croak("Size %d of packed data != expected %d",
			len, sizeof(sound));
	    sound = *(Sound *)s;
	}
	else
	    croak("sound is not of type Sound")
;

	UnloadSound(sound);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_UnloadSpriteFont); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_UnloadSpriteFont)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "spriteFont");
    {
	SpriteFont	spriteFont;

	if (sv_derived_from(ST(0), "SpriteFont")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(spriteFont))
		croak("Size %d of packed data != expected %d",
			len, sizeof(spriteFont));
	    spriteFont = *(SpriteFont *)s;
	}
	else
	    croak("spriteFont is not of type SpriteFont")
;

	UnloadSpriteFont(spriteFont);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_UnloadTexture); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_UnloadTexture)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "texture");
    {
	Texture2D	texture;

	if (sv_derived_from(ST(0), "Texture2D")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(texture))
		croak("Size %d of packed data != expected %d",
			len, sizeof(texture));
	    texture = *(Texture2D *)s;
	}
	else
	    croak("texture is not of type Texture2D")
;

	UnloadTexture(texture);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_UnloadWave); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_UnloadWave)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "wave");
    {
	Wave	wave;

	if (sv_derived_from(ST(0), "Wave")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(wave))
		croak("Size %d of packed data != expected %d",
			len, sizeof(wave));
	    wave = *(Wave *)s;
	}
	else
	    croak("wave is not of type Wave")
;

	UnloadWave(wave);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_UpdateAudioStream); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_UpdateAudioStream)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "stream, data, numSamples");
    {
	AudioStream	stream;
	void *	data = INT2PTR(void *,SvIV(ST(1)))
;
	int	numSamples = (int)SvIV(ST(2))
;

	if (sv_derived_from(ST(0), "AudioStream")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(stream))
		croak("Size %d of packed data != expected %d",
			len, sizeof(stream));
	    stream = *(AudioStream *)s;
	}
	else
	    croak("stream is not of type AudioStream")
;

	UpdateAudioStream(stream, data, numSamples);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_UpdateCamera); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_UpdateCamera)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "camera");
    {
	Camera *	camera;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "CameraPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    camera = INT2PTR(Camera *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::UpdateCamera",
			"camera", "CameraPtr")
;

	UpdateCamera(camera);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_UpdateMusicStream); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_UpdateMusicStream)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "music");
    {
	Music	music;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Music")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    music = INT2PTR(Music,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::UpdateMusicStream",
			"music", "Music")
;

	UpdateMusicStream(music);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_UpdateSound); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_UpdateSound)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "sound, data, numSamples");
    {
	Sound	sound;
	void *	data = INT2PTR(void *,SvIV(ST(1)))
;
	int	numSamples = (int)SvIV(ST(2))
;

	if (sv_derived_from(ST(0), "Sound")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(sound))
		croak("Size %d of packed data != expected %d",
			len, sizeof(sound));
	    sound = *(Sound *)s;
	}
	else
	    croak("sound is not of type Sound")
;

	UpdateSound(sound, data, numSamples);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_UpdateTexture); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_UpdateTexture)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "texture, pixels");
    {
	Texture2D	texture;
	void *	pixels = INT2PTR(void *,SvIV(ST(1)))
;

	if (sv_derived_from(ST(0), "Texture2D")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(texture))
		croak("Size %d of packed data != expected %d",
			len, sizeof(texture));
	    texture = *(Texture2D *)s;
	}
	else
	    croak("texture is not of type Texture2D")
;

	UpdateTexture(texture, pixels);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_UpdateVrTracking); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_UpdateVrTracking)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "camera");
    {
	Camera *	camera;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "CameraPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    camera = INT2PTR(Camera *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::UpdateVrTracking",
			"camera", "CameraPtr")
;

	UpdateVrTracking(camera);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_VectorToFloat); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_VectorToFloat)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "vec");
    {
	Vector3	vec;
	float *	RETVAL;

	if (sv_derived_from(ST(0), "Vector3")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(vec))
		croak("Size %d of packed data != expected %d",
			len, sizeof(vec));
	    vec = *(Vector3 *)s;
	}
	else
	    croak("vec is not of type Vector3")
;

	RETVAL = VectorToFloat(vec);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "floatPtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_WaveCopy); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_WaveCopy)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "wave");
    {
	Wave	wave;
	Wave	RETVAL;

	if (sv_derived_from(ST(0), "Wave")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV(ST(0)), len);
	    if (len != sizeof(wave))
		croak("Size %d of packed data != expected %d",
			len, sizeof(wave));
	    wave = *(Wave *)s;
	}
	else
	    croak("wave is not of type Wave")
;

	RETVAL = WaveCopy(wave);
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pvn(RETVALSV, "Wave", (char *)&RETVAL, sizeof(RETVAL));
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Graphics__Raylib__XS_WaveCrop); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_WaveCrop)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "wave, initSample, finalSample");
    {
	Wave *	wave;
	int	initSample = (int)SvIV(ST(1))
;
	int	finalSample = (int)SvIV(ST(2))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "WavePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    wave = INT2PTR(Wave *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::WaveCrop",
			"wave", "WavePtr")
;

	WaveCrop(wave, initSample, finalSample);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_WaveFormat); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_WaveFormat)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "wave, sampleRate, sampleSize, channels");
    {
	Wave *	wave;
	int	sampleRate = (int)SvIV(ST(1))
;
	int	sampleSize = (int)SvIV(ST(2))
;
	int	channels = (int)SvIV(ST(3))
;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "WavePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    wave = INT2PTR(Wave *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Graphics::Raylib::XS::WaveFormat",
			"wave", "WavePtr")
;

	WaveFormat(wave, sampleRate, sampleSize, channels);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Graphics__Raylib__XS_WindowShouldClose); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Graphics__Raylib__XS_WindowShouldClose)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = WindowShouldClose();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Graphics__Raylib__XS); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Graphics__Raylib__XS)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        newXS_deffile("Graphics::Raylib::XS::constant", XS_Graphics__Raylib__XS_constant);
        newXS_deffile("Graphics::Raylib::XS::Begin2dMode", XS_Graphics__Raylib__XS_Begin2dMode);
        newXS_deffile("Graphics::Raylib::XS::Begin3dMode", XS_Graphics__Raylib__XS_Begin3dMode);
        newXS_deffile("Graphics::Raylib::XS::BeginBlendMode", XS_Graphics__Raylib__XS_BeginBlendMode);
        newXS_deffile("Graphics::Raylib::XS::BeginDrawing", XS_Graphics__Raylib__XS_BeginDrawing);
        newXS_deffile("Graphics::Raylib::XS::BeginShaderMode", XS_Graphics__Raylib__XS_BeginShaderMode);
        newXS_deffile("Graphics::Raylib::XS::BeginTextureMode", XS_Graphics__Raylib__XS_BeginTextureMode);
        newXS_deffile("Graphics::Raylib::XS::CalculateBoundingBox", XS_Graphics__Raylib__XS_CalculateBoundingBox);
        newXS_deffile("Graphics::Raylib::XS::CheckCollisionBoxSphere", XS_Graphics__Raylib__XS_CheckCollisionBoxSphere);
        newXS_deffile("Graphics::Raylib::XS::CheckCollisionBoxes", XS_Graphics__Raylib__XS_CheckCollisionBoxes);
        newXS_deffile("Graphics::Raylib::XS::CheckCollisionCircleRec", XS_Graphics__Raylib__XS_CheckCollisionCircleRec);
        newXS_deffile("Graphics::Raylib::XS::CheckCollisionCircles", XS_Graphics__Raylib__XS_CheckCollisionCircles);
        newXS_deffile("Graphics::Raylib::XS::CheckCollisionPointCircle", XS_Graphics__Raylib__XS_CheckCollisionPointCircle);
        newXS_deffile("Graphics::Raylib::XS::CheckCollisionPointRec", XS_Graphics__Raylib__XS_CheckCollisionPointRec);
        newXS_deffile("Graphics::Raylib::XS::CheckCollisionPointTriangle", XS_Graphics__Raylib__XS_CheckCollisionPointTriangle);
        newXS_deffile("Graphics::Raylib::XS::CheckCollisionRayBox", XS_Graphics__Raylib__XS_CheckCollisionRayBox);
        newXS_deffile("Graphics::Raylib::XS::CheckCollisionRaySphere", XS_Graphics__Raylib__XS_CheckCollisionRaySphere);
        newXS_deffile("Graphics::Raylib::XS::CheckCollisionRaySphereEx", XS_Graphics__Raylib__XS_CheckCollisionRaySphereEx);
        newXS_deffile("Graphics::Raylib::XS::CheckCollisionRecs", XS_Graphics__Raylib__XS_CheckCollisionRecs);
        newXS_deffile("Graphics::Raylib::XS::CheckCollisionSpheres", XS_Graphics__Raylib__XS_CheckCollisionSpheres);
        newXS_deffile("Graphics::Raylib::XS::ClearBackground", XS_Graphics__Raylib__XS_ClearBackground);
        newXS_deffile("Graphics::Raylib::XS::ClearDroppedFiles", XS_Graphics__Raylib__XS_ClearDroppedFiles);
        newXS_deffile("Graphics::Raylib::XS::CloseAudioDevice", XS_Graphics__Raylib__XS_CloseAudioDevice);
        newXS_deffile("Graphics::Raylib::XS::CloseAudioStream", XS_Graphics__Raylib__XS_CloseAudioStream);
        newXS_deffile("Graphics::Raylib::XS::CloseVrDevice", XS_Graphics__Raylib__XS_CloseVrDevice);
        newXS_deffile("Graphics::Raylib::XS::CloseWindow", XS_Graphics__Raylib__XS_CloseWindow);
        newXS_deffile("Graphics::Raylib::XS::ColorToFloat", XS_Graphics__Raylib__XS_ColorToFloat);
        newXS_deffile("Graphics::Raylib::XS::CreateLight", XS_Graphics__Raylib__XS_CreateLight);
        newXS_deffile("Graphics::Raylib::XS::DestroyLight", XS_Graphics__Raylib__XS_DestroyLight);
        newXS_deffile("Graphics::Raylib::XS::DisableCursor", XS_Graphics__Raylib__XS_DisableCursor);
        newXS_deffile("Graphics::Raylib::XS::DrawBillboard", XS_Graphics__Raylib__XS_DrawBillboard);
        newXS_deffile("Graphics::Raylib::XS::DrawBillboardRec", XS_Graphics__Raylib__XS_DrawBillboardRec);
        newXS_deffile("Graphics::Raylib::XS::DrawBoundingBox", XS_Graphics__Raylib__XS_DrawBoundingBox);
        newXS_deffile("Graphics::Raylib::XS::DrawCircle", XS_Graphics__Raylib__XS_DrawCircle);
        newXS_deffile("Graphics::Raylib::XS::DrawCircle3D", XS_Graphics__Raylib__XS_DrawCircle3D);
        newXS_deffile("Graphics::Raylib::XS::DrawCircleGradient", XS_Graphics__Raylib__XS_DrawCircleGradient);
        newXS_deffile("Graphics::Raylib::XS::DrawCircleLines", XS_Graphics__Raylib__XS_DrawCircleLines);
        newXS_deffile("Graphics::Raylib::XS::DrawCircleV", XS_Graphics__Raylib__XS_DrawCircleV);
        newXS_deffile("Graphics::Raylib::XS::DrawCube", XS_Graphics__Raylib__XS_DrawCube);
        newXS_deffile("Graphics::Raylib::XS::DrawCubeTexture", XS_Graphics__Raylib__XS_DrawCubeTexture);
        newXS_deffile("Graphics::Raylib::XS::DrawCubeV", XS_Graphics__Raylib__XS_DrawCubeV);
        newXS_deffile("Graphics::Raylib::XS::DrawCubeWires", XS_Graphics__Raylib__XS_DrawCubeWires);
        newXS_deffile("Graphics::Raylib::XS::DrawCylinder", XS_Graphics__Raylib__XS_DrawCylinder);
        newXS_deffile("Graphics::Raylib::XS::DrawCylinderWires", XS_Graphics__Raylib__XS_DrawCylinderWires);
        newXS_deffile("Graphics::Raylib::XS::DrawFPS", XS_Graphics__Raylib__XS_DrawFPS);
        newXS_deffile("Graphics::Raylib::XS::DrawGizmo", XS_Graphics__Raylib__XS_DrawGizmo);
        newXS_deffile("Graphics::Raylib::XS::DrawGrid", XS_Graphics__Raylib__XS_DrawGrid);
        newXS_deffile("Graphics::Raylib::XS::DrawLight", XS_Graphics__Raylib__XS_DrawLight);
        newXS_deffile("Graphics::Raylib::XS::DrawLine", XS_Graphics__Raylib__XS_DrawLine);
        newXS_deffile("Graphics::Raylib::XS::DrawLine3D", XS_Graphics__Raylib__XS_DrawLine3D);
        newXS_deffile("Graphics::Raylib::XS::DrawLineV", XS_Graphics__Raylib__XS_DrawLineV);
        newXS_deffile("Graphics::Raylib::XS::DrawModel", XS_Graphics__Raylib__XS_DrawModel);
        newXS_deffile("Graphics::Raylib::XS::DrawModelEx", XS_Graphics__Raylib__XS_DrawModelEx);
        newXS_deffile("Graphics::Raylib::XS::DrawModelWires", XS_Graphics__Raylib__XS_DrawModelWires);
        newXS_deffile("Graphics::Raylib::XS::DrawModelWiresEx", XS_Graphics__Raylib__XS_DrawModelWiresEx);
        newXS_deffile("Graphics::Raylib::XS::DrawPixel", XS_Graphics__Raylib__XS_DrawPixel);
        newXS_deffile("Graphics::Raylib::XS::DrawPixelV", XS_Graphics__Raylib__XS_DrawPixelV);
        newXS_deffile("Graphics::Raylib::XS::DrawPlane", XS_Graphics__Raylib__XS_DrawPlane);
        newXS_deffile("Graphics::Raylib::XS::DrawPoly", XS_Graphics__Raylib__XS_DrawPoly);
        newXS_deffile("Graphics::Raylib::XS::DrawPolyEx", XS_Graphics__Raylib__XS_DrawPolyEx);
        newXS_deffile("Graphics::Raylib::XS::DrawPolyExLines", XS_Graphics__Raylib__XS_DrawPolyExLines);
        newXS_deffile("Graphics::Raylib::XS::DrawRay", XS_Graphics__Raylib__XS_DrawRay);
        newXS_deffile("Graphics::Raylib::XS::DrawRectangle", XS_Graphics__Raylib__XS_DrawRectangle);
        newXS_deffile("Graphics::Raylib::XS::DrawRectangleGradient", XS_Graphics__Raylib__XS_DrawRectangleGradient);
        newXS_deffile("Graphics::Raylib::XS::DrawRectangleLines", XS_Graphics__Raylib__XS_DrawRectangleLines);
        newXS_deffile("Graphics::Raylib::XS::DrawRectangleRec", XS_Graphics__Raylib__XS_DrawRectangleRec);
        newXS_deffile("Graphics::Raylib::XS::DrawRectangleV", XS_Graphics__Raylib__XS_DrawRectangleV);
        newXS_deffile("Graphics::Raylib::XS::DrawSphere", XS_Graphics__Raylib__XS_DrawSphere);
        newXS_deffile("Graphics::Raylib::XS::DrawSphereEx", XS_Graphics__Raylib__XS_DrawSphereEx);
        newXS_deffile("Graphics::Raylib::XS::DrawSphereWires", XS_Graphics__Raylib__XS_DrawSphereWires);
        newXS_deffile("Graphics::Raylib::XS::DrawText", XS_Graphics__Raylib__XS_DrawText);
        newXS_deffile("Graphics::Raylib::XS::DrawTextEx", XS_Graphics__Raylib__XS_DrawTextEx);
        newXS_deffile("Graphics::Raylib::XS::DrawTexture", XS_Graphics__Raylib__XS_DrawTexture);
        newXS_deffile("Graphics::Raylib::XS::DrawTextureEx", XS_Graphics__Raylib__XS_DrawTextureEx);
        newXS_deffile("Graphics::Raylib::XS::DrawTexturePro", XS_Graphics__Raylib__XS_DrawTexturePro);
        newXS_deffile("Graphics::Raylib::XS::DrawTextureRec", XS_Graphics__Raylib__XS_DrawTextureRec);
        newXS_deffile("Graphics::Raylib::XS::DrawTextureV", XS_Graphics__Raylib__XS_DrawTextureV);
        newXS_deffile("Graphics::Raylib::XS::DrawTriangle", XS_Graphics__Raylib__XS_DrawTriangle);
        newXS_deffile("Graphics::Raylib::XS::DrawTriangleLines", XS_Graphics__Raylib__XS_DrawTriangleLines);
        newXS_deffile("Graphics::Raylib::XS::EnableCursor", XS_Graphics__Raylib__XS_EnableCursor);
        newXS_deffile("Graphics::Raylib::XS::End2dMode", XS_Graphics__Raylib__XS_End2dMode);
        newXS_deffile("Graphics::Raylib::XS::End3dMode", XS_Graphics__Raylib__XS_End3dMode);
        newXS_deffile("Graphics::Raylib::XS::EndBlendMode", XS_Graphics__Raylib__XS_EndBlendMode);
        newXS_deffile("Graphics::Raylib::XS::EndDrawing", XS_Graphics__Raylib__XS_EndDrawing);
        newXS_deffile("Graphics::Raylib::XS::EndShaderMode", XS_Graphics__Raylib__XS_EndShaderMode);
        newXS_deffile("Graphics::Raylib::XS::EndTextureMode", XS_Graphics__Raylib__XS_EndTextureMode);
        newXS_deffile("Graphics::Raylib::XS::Fade", XS_Graphics__Raylib__XS_Fade);
        newXS_deffile("Graphics::Raylib::XS::FormatText", XS_Graphics__Raylib__XS_FormatText);
        newXS_deffile("Graphics::Raylib::XS::GenTextureMipmaps", XS_Graphics__Raylib__XS_GenTextureMipmaps);
        newXS_deffile("Graphics::Raylib::XS::GetCameraMatrix", XS_Graphics__Raylib__XS_GetCameraMatrix);
        newXS_deffile("Graphics::Raylib::XS::GetCollisionRec", XS_Graphics__Raylib__XS_GetCollisionRec);
        newXS_deffile("Graphics::Raylib::XS::GetColor", XS_Graphics__Raylib__XS_GetColor);
        newXS_deffile("Graphics::Raylib::XS::GetDefaultFont", XS_Graphics__Raylib__XS_GetDefaultFont);
        newXS_deffile("Graphics::Raylib::XS::GetDefaultShader", XS_Graphics__Raylib__XS_GetDefaultShader);
        newXS_deffile("Graphics::Raylib::XS::GetDefaultTexture", XS_Graphics__Raylib__XS_GetDefaultTexture);
        newXS_deffile("Graphics::Raylib::XS::GetFPS", XS_Graphics__Raylib__XS_GetFPS);
        newXS_deffile("Graphics::Raylib::XS::GetFrameTime", XS_Graphics__Raylib__XS_GetFrameTime);
        newXS_deffile("Graphics::Raylib::XS::GetGamepadAxisCount", XS_Graphics__Raylib__XS_GetGamepadAxisCount);
        newXS_deffile("Graphics::Raylib::XS::GetGamepadAxisMovement", XS_Graphics__Raylib__XS_GetGamepadAxisMovement);
        newXS_deffile("Graphics::Raylib::XS::GetGamepadButtonPressed", XS_Graphics__Raylib__XS_GetGamepadButtonPressed);
        newXS_deffile("Graphics::Raylib::XS::GetGamepadName", XS_Graphics__Raylib__XS_GetGamepadName);
        newXS_deffile("Graphics::Raylib::XS::GetGestureDetected", XS_Graphics__Raylib__XS_GetGestureDetected);
        newXS_deffile("Graphics::Raylib::XS::GetGestureDragAngle", XS_Graphics__Raylib__XS_GetGestureDragAngle);
        newXS_deffile("Graphics::Raylib::XS::GetGestureDragVector", XS_Graphics__Raylib__XS_GetGestureDragVector);
        newXS_deffile("Graphics::Raylib::XS::GetGestureHoldDuration", XS_Graphics__Raylib__XS_GetGestureHoldDuration);
        newXS_deffile("Graphics::Raylib::XS::GetGesturePinchAngle", XS_Graphics__Raylib__XS_GetGesturePinchAngle);
        newXS_deffile("Graphics::Raylib::XS::GetGesturePinchVector", XS_Graphics__Raylib__XS_GetGesturePinchVector);
        newXS_deffile("Graphics::Raylib::XS::GetHexValue", XS_Graphics__Raylib__XS_GetHexValue);
        newXS_deffile("Graphics::Raylib::XS::GetImageData", XS_Graphics__Raylib__XS_GetImageData);
        newXS_deffile("Graphics::Raylib::XS::GetKeyPressed", XS_Graphics__Raylib__XS_GetKeyPressed);
        newXS_deffile("Graphics::Raylib::XS::GetMousePosition", XS_Graphics__Raylib__XS_GetMousePosition);
        newXS_deffile("Graphics::Raylib::XS::GetMouseRay", XS_Graphics__Raylib__XS_GetMouseRay);
        newXS_deffile("Graphics::Raylib::XS::GetMouseWheelMove", XS_Graphics__Raylib__XS_GetMouseWheelMove);
        newXS_deffile("Graphics::Raylib::XS::GetMouseX", XS_Graphics__Raylib__XS_GetMouseX);
        newXS_deffile("Graphics::Raylib::XS::GetMouseY", XS_Graphics__Raylib__XS_GetMouseY);
        newXS_deffile("Graphics::Raylib::XS::GetMusicTimeLength", XS_Graphics__Raylib__XS_GetMusicTimeLength);
        newXS_deffile("Graphics::Raylib::XS::GetMusicTimePlayed", XS_Graphics__Raylib__XS_GetMusicTimePlayed);
        newXS_deffile("Graphics::Raylib::XS::GetRandomValue", XS_Graphics__Raylib__XS_GetRandomValue);
        newXS_deffile("Graphics::Raylib::XS::GetScreenHeight", XS_Graphics__Raylib__XS_GetScreenHeight);
        newXS_deffile("Graphics::Raylib::XS::GetScreenWidth", XS_Graphics__Raylib__XS_GetScreenWidth);
        newXS_deffile("Graphics::Raylib::XS::GetShaderLocation", XS_Graphics__Raylib__XS_GetShaderLocation);
        newXS_deffile("Graphics::Raylib::XS::GetStandardShader", XS_Graphics__Raylib__XS_GetStandardShader);
        newXS_deffile("Graphics::Raylib::XS::GetTextureData", XS_Graphics__Raylib__XS_GetTextureData);
        newXS_deffile("Graphics::Raylib::XS::GetTouchPointsCount", XS_Graphics__Raylib__XS_GetTouchPointsCount);
        newXS_deffile("Graphics::Raylib::XS::GetTouchPosition", XS_Graphics__Raylib__XS_GetTouchPosition);
        newXS_deffile("Graphics::Raylib::XS::GetTouchX", XS_Graphics__Raylib__XS_GetTouchX);
        newXS_deffile("Graphics::Raylib::XS::GetTouchY", XS_Graphics__Raylib__XS_GetTouchY);
        newXS_deffile("Graphics::Raylib::XS::GetWaveData", XS_Graphics__Raylib__XS_GetWaveData);
        newXS_deffile("Graphics::Raylib::XS::GetWorldToScreen", XS_Graphics__Raylib__XS_GetWorldToScreen);
        newXS_deffile("Graphics::Raylib::XS::HideCursor", XS_Graphics__Raylib__XS_HideCursor);
        newXS_deffile("Graphics::Raylib::XS::ImageAlphaMask", XS_Graphics__Raylib__XS_ImageAlphaMask);
        newXS_deffile("Graphics::Raylib::XS::ImageColorBrightness", XS_Graphics__Raylib__XS_ImageColorBrightness);
        newXS_deffile("Graphics::Raylib::XS::ImageColorContrast", XS_Graphics__Raylib__XS_ImageColorContrast);
        newXS_deffile("Graphics::Raylib::XS::ImageColorGrayscale", XS_Graphics__Raylib__XS_ImageColorGrayscale);
        newXS_deffile("Graphics::Raylib::XS::ImageColorInvert", XS_Graphics__Raylib__XS_ImageColorInvert);
        newXS_deffile("Graphics::Raylib::XS::ImageColorTint", XS_Graphics__Raylib__XS_ImageColorTint);
        newXS_deffile("Graphics::Raylib::XS::ImageCopy", XS_Graphics__Raylib__XS_ImageCopy);
        newXS_deffile("Graphics::Raylib::XS::ImageCrop", XS_Graphics__Raylib__XS_ImageCrop);
        newXS_deffile("Graphics::Raylib::XS::ImageDither", XS_Graphics__Raylib__XS_ImageDither);
        newXS_deffile("Graphics::Raylib::XS::ImageDraw", XS_Graphics__Raylib__XS_ImageDraw);
        newXS_deffile("Graphics::Raylib::XS::ImageDrawText", XS_Graphics__Raylib__XS_ImageDrawText);
        newXS_deffile("Graphics::Raylib::XS::ImageDrawTextEx", XS_Graphics__Raylib__XS_ImageDrawTextEx);
        newXS_deffile("Graphics::Raylib::XS::ImageFlipHorizontal", XS_Graphics__Raylib__XS_ImageFlipHorizontal);
        newXS_deffile("Graphics::Raylib::XS::ImageFlipVertical", XS_Graphics__Raylib__XS_ImageFlipVertical);
        newXS_deffile("Graphics::Raylib::XS::ImageFormat", XS_Graphics__Raylib__XS_ImageFormat);
        newXS_deffile("Graphics::Raylib::XS::ImageResize", XS_Graphics__Raylib__XS_ImageResize);
        newXS_deffile("Graphics::Raylib::XS::ImageResizeNN", XS_Graphics__Raylib__XS_ImageResizeNN);
        newXS_deffile("Graphics::Raylib::XS::ImageText", XS_Graphics__Raylib__XS_ImageText);
        newXS_deffile("Graphics::Raylib::XS::ImageTextEx", XS_Graphics__Raylib__XS_ImageTextEx);
        newXS_deffile("Graphics::Raylib::XS::ImageToPOT", XS_Graphics__Raylib__XS_ImageToPOT);
        newXS_deffile("Graphics::Raylib::XS::InitAudioDevice", XS_Graphics__Raylib__XS_InitAudioDevice);
        newXS_deffile("Graphics::Raylib::XS::InitAudioStream", XS_Graphics__Raylib__XS_InitAudioStream);
        newXS_deffile("Graphics::Raylib::XS::InitVrDevice", XS_Graphics__Raylib__XS_InitVrDevice);
        newXS_deffile("Graphics::Raylib::XS::InitWindow", XS_Graphics__Raylib__XS_InitWindow);
        newXS_deffile("Graphics::Raylib::XS::IsAudioBufferProcessed", XS_Graphics__Raylib__XS_IsAudioBufferProcessed);
        newXS_deffile("Graphics::Raylib::XS::IsAudioDeviceReady", XS_Graphics__Raylib__XS_IsAudioDeviceReady);
        newXS_deffile("Graphics::Raylib::XS::IsCursorHidden", XS_Graphics__Raylib__XS_IsCursorHidden);
        newXS_deffile("Graphics::Raylib::XS::IsFileDropped", XS_Graphics__Raylib__XS_IsFileDropped);
        newXS_deffile("Graphics::Raylib::XS::IsGamepadAvailable", XS_Graphics__Raylib__XS_IsGamepadAvailable);
        newXS_deffile("Graphics::Raylib::XS::IsGamepadButtonDown", XS_Graphics__Raylib__XS_IsGamepadButtonDown);
        newXS_deffile("Graphics::Raylib::XS::IsGamepadButtonPressed", XS_Graphics__Raylib__XS_IsGamepadButtonPressed);
        newXS_deffile("Graphics::Raylib::XS::IsGamepadButtonReleased", XS_Graphics__Raylib__XS_IsGamepadButtonReleased);
        newXS_deffile("Graphics::Raylib::XS::IsGamepadButtonUp", XS_Graphics__Raylib__XS_IsGamepadButtonUp);
        newXS_deffile("Graphics::Raylib::XS::IsGamepadName", XS_Graphics__Raylib__XS_IsGamepadName);
        newXS_deffile("Graphics::Raylib::XS::IsGestureDetected", XS_Graphics__Raylib__XS_IsGestureDetected);
        newXS_deffile("Graphics::Raylib::XS::IsKeyDown", XS_Graphics__Raylib__XS_IsKeyDown);
        newXS_deffile("Graphics::Raylib::XS::IsKeyPressed", XS_Graphics__Raylib__XS_IsKeyPressed);
        newXS_deffile("Graphics::Raylib::XS::IsKeyReleased", XS_Graphics__Raylib__XS_IsKeyReleased);
        newXS_deffile("Graphics::Raylib::XS::IsKeyUp", XS_Graphics__Raylib__XS_IsKeyUp);
        newXS_deffile("Graphics::Raylib::XS::IsMouseButtonDown", XS_Graphics__Raylib__XS_IsMouseButtonDown);
        newXS_deffile("Graphics::Raylib::XS::IsMouseButtonPressed", XS_Graphics__Raylib__XS_IsMouseButtonPressed);
        newXS_deffile("Graphics::Raylib::XS::IsMouseButtonReleased", XS_Graphics__Raylib__XS_IsMouseButtonReleased);
        newXS_deffile("Graphics::Raylib::XS::IsMouseButtonUp", XS_Graphics__Raylib__XS_IsMouseButtonUp);
        newXS_deffile("Graphics::Raylib::XS::IsMusicPlaying", XS_Graphics__Raylib__XS_IsMusicPlaying);
        newXS_deffile("Graphics::Raylib::XS::IsSoundPlaying", XS_Graphics__Raylib__XS_IsSoundPlaying);
        newXS_deffile("Graphics::Raylib::XS::IsVrDeviceReady", XS_Graphics__Raylib__XS_IsVrDeviceReady);
        newXS_deffile("Graphics::Raylib::XS::IsVrSimulator", XS_Graphics__Raylib__XS_IsVrSimulator);
        newXS_deffile("Graphics::Raylib::XS::IsWindowMinimized", XS_Graphics__Raylib__XS_IsWindowMinimized);
        newXS_deffile("Graphics::Raylib::XS::LoadCubicmap", XS_Graphics__Raylib__XS_LoadCubicmap);
        newXS_deffile("Graphics::Raylib::XS::LoadDefaultMaterial", XS_Graphics__Raylib__XS_LoadDefaultMaterial);
        newXS_deffile("Graphics::Raylib::XS::LoadHeightmap", XS_Graphics__Raylib__XS_LoadHeightmap);
        newXS_deffile("Graphics::Raylib::XS::LoadImage", XS_Graphics__Raylib__XS_LoadImage);
        newXS_deffile("Graphics::Raylib::XS::LoadImageEx", XS_Graphics__Raylib__XS_LoadImageEx);
        newXS_deffile("Graphics::Raylib::XS::LoadImageFromRES", XS_Graphics__Raylib__XS_LoadImageFromRES);
        newXS_deffile("Graphics::Raylib::XS::LoadImageRaw", XS_Graphics__Raylib__XS_LoadImageRaw);
        newXS_deffile("Graphics::Raylib::XS::LoadMaterial", XS_Graphics__Raylib__XS_LoadMaterial);
        newXS_deffile("Graphics::Raylib::XS::LoadModel", XS_Graphics__Raylib__XS_LoadModel);
        newXS_deffile("Graphics::Raylib::XS::LoadModelEx", XS_Graphics__Raylib__XS_LoadModelEx);
        newXS_deffile("Graphics::Raylib::XS::LoadModelFromRES", XS_Graphics__Raylib__XS_LoadModelFromRES);
        newXS_deffile("Graphics::Raylib::XS::LoadMusicStream", XS_Graphics__Raylib__XS_LoadMusicStream);
        newXS_deffile("Graphics::Raylib::XS::LoadRenderTexture", XS_Graphics__Raylib__XS_LoadRenderTexture);
        newXS_deffile("Graphics::Raylib::XS::LoadShader", XS_Graphics__Raylib__XS_LoadShader);
        newXS_deffile("Graphics::Raylib::XS::LoadSound", XS_Graphics__Raylib__XS_LoadSound);
        newXS_deffile("Graphics::Raylib::XS::LoadSoundFromRES", XS_Graphics__Raylib__XS_LoadSoundFromRES);
        newXS_deffile("Graphics::Raylib::XS::LoadSoundFromWave", XS_Graphics__Raylib__XS_LoadSoundFromWave);
        newXS_deffile("Graphics::Raylib::XS::LoadSpriteFont", XS_Graphics__Raylib__XS_LoadSpriteFont);
        newXS_deffile("Graphics::Raylib::XS::LoadSpriteFontTTF", XS_Graphics__Raylib__XS_LoadSpriteFontTTF);
        newXS_deffile("Graphics::Raylib::XS::LoadStandardMaterial", XS_Graphics__Raylib__XS_LoadStandardMaterial);
        newXS_deffile("Graphics::Raylib::XS::LoadTexture", XS_Graphics__Raylib__XS_LoadTexture);
        newXS_deffile("Graphics::Raylib::XS::LoadTextureEx", XS_Graphics__Raylib__XS_LoadTextureEx);
        newXS_deffile("Graphics::Raylib::XS::LoadTextureFromImage", XS_Graphics__Raylib__XS_LoadTextureFromImage);
        newXS_deffile("Graphics::Raylib::XS::LoadTextureFromRES", XS_Graphics__Raylib__XS_LoadTextureFromRES);
        newXS_deffile("Graphics::Raylib::XS::LoadWave", XS_Graphics__Raylib__XS_LoadWave);
        newXS_deffile("Graphics::Raylib::XS::LoadWaveEx", XS_Graphics__Raylib__XS_LoadWaveEx);
        newXS_deffile("Graphics::Raylib::XS::MatrixToFloat", XS_Graphics__Raylib__XS_MatrixToFloat);
        newXS_deffile("Graphics::Raylib::XS::MeasureText", XS_Graphics__Raylib__XS_MeasureText);
        newXS_deffile("Graphics::Raylib::XS::MeasureTextEx", XS_Graphics__Raylib__XS_MeasureTextEx);
        newXS_deffile("Graphics::Raylib::XS::PauseAudioStream", XS_Graphics__Raylib__XS_PauseAudioStream);
        newXS_deffile("Graphics::Raylib::XS::PauseMusicStream", XS_Graphics__Raylib__XS_PauseMusicStream);
        newXS_deffile("Graphics::Raylib::XS::PauseSound", XS_Graphics__Raylib__XS_PauseSound);
        newXS_deffile("Graphics::Raylib::XS::PlayAudioStream", XS_Graphics__Raylib__XS_PlayAudioStream);
        newXS_deffile("Graphics::Raylib::XS::PlayMusicStream", XS_Graphics__Raylib__XS_PlayMusicStream);
        newXS_deffile("Graphics::Raylib::XS::PlaySound", XS_Graphics__Raylib__XS_PlaySound);
        newXS_deffile("Graphics::Raylib::XS::ResumeAudioStream", XS_Graphics__Raylib__XS_ResumeAudioStream);
        newXS_deffile("Graphics::Raylib::XS::ResumeMusicStream", XS_Graphics__Raylib__XS_ResumeMusicStream);
        newXS_deffile("Graphics::Raylib::XS::ResumeSound", XS_Graphics__Raylib__XS_ResumeSound);
        newXS_deffile("Graphics::Raylib::XS::SetCameraAltControl", XS_Graphics__Raylib__XS_SetCameraAltControl);
        newXS_deffile("Graphics::Raylib::XS::SetCameraMode", XS_Graphics__Raylib__XS_SetCameraMode);
        newXS_deffile("Graphics::Raylib::XS::SetCameraMoveControls", XS_Graphics__Raylib__XS_SetCameraMoveControls);
        newXS_deffile("Graphics::Raylib::XS::SetCameraPanControl", XS_Graphics__Raylib__XS_SetCameraPanControl);
        newXS_deffile("Graphics::Raylib::XS::SetCameraSmoothZoomControl", XS_Graphics__Raylib__XS_SetCameraSmoothZoomControl);
        newXS_deffile("Graphics::Raylib::XS::SetConfigFlags", XS_Graphics__Raylib__XS_SetConfigFlags);
        newXS_deffile("Graphics::Raylib::XS::SetExitKey", XS_Graphics__Raylib__XS_SetExitKey);
        newXS_deffile("Graphics::Raylib::XS::SetGesturesEnabled", XS_Graphics__Raylib__XS_SetGesturesEnabled);
        newXS_deffile("Graphics::Raylib::XS::SetMatrixModelview", XS_Graphics__Raylib__XS_SetMatrixModelview);
        newXS_deffile("Graphics::Raylib::XS::SetMatrixProjection", XS_Graphics__Raylib__XS_SetMatrixProjection);
        newXS_deffile("Graphics::Raylib::XS::SetMousePosition", XS_Graphics__Raylib__XS_SetMousePosition);
        newXS_deffile("Graphics::Raylib::XS::SetMusicPitch", XS_Graphics__Raylib__XS_SetMusicPitch);
        newXS_deffile("Graphics::Raylib::XS::SetMusicVolume", XS_Graphics__Raylib__XS_SetMusicVolume);
        newXS_deffile("Graphics::Raylib::XS::SetShaderValue", XS_Graphics__Raylib__XS_SetShaderValue);
        newXS_deffile("Graphics::Raylib::XS::SetShaderValueMatrix", XS_Graphics__Raylib__XS_SetShaderValueMatrix);
        newXS_deffile("Graphics::Raylib::XS::SetShaderValuei", XS_Graphics__Raylib__XS_SetShaderValuei);
        newXS_deffile("Graphics::Raylib::XS::SetSoundPitch", XS_Graphics__Raylib__XS_SetSoundPitch);
        newXS_deffile("Graphics::Raylib::XS::SetSoundVolume", XS_Graphics__Raylib__XS_SetSoundVolume);
        newXS_deffile("Graphics::Raylib::XS::SetTargetFPS", XS_Graphics__Raylib__XS_SetTargetFPS);
        newXS_deffile("Graphics::Raylib::XS::SetTextureFilter", XS_Graphics__Raylib__XS_SetTextureFilter);
        newXS_deffile("Graphics::Raylib::XS::SetTextureWrap", XS_Graphics__Raylib__XS_SetTextureWrap);
        newXS_deffile("Graphics::Raylib::XS::ShowCursor", XS_Graphics__Raylib__XS_ShowCursor);
        newXS_deffile("Graphics::Raylib::XS::ShowLogo", XS_Graphics__Raylib__XS_ShowLogo);
        newXS_deffile("Graphics::Raylib::XS::StopAudioStream", XS_Graphics__Raylib__XS_StopAudioStream);
        newXS_deffile("Graphics::Raylib::XS::StopMusicStream", XS_Graphics__Raylib__XS_StopMusicStream);
        newXS_deffile("Graphics::Raylib::XS::StopSound", XS_Graphics__Raylib__XS_StopSound);
        newXS_deffile("Graphics::Raylib::XS::StorageLoadValue", XS_Graphics__Raylib__XS_StorageLoadValue);
        newXS_deffile("Graphics::Raylib::XS::StorageSaveValue", XS_Graphics__Raylib__XS_StorageSaveValue);
        newXS_deffile("Graphics::Raylib::XS::SubText", XS_Graphics__Raylib__XS_SubText);
        newXS_deffile("Graphics::Raylib::XS::ToggleFullscreen", XS_Graphics__Raylib__XS_ToggleFullscreen);
        newXS_deffile("Graphics::Raylib::XS::ToggleVrMode", XS_Graphics__Raylib__XS_ToggleVrMode);
        newXS_deffile("Graphics::Raylib::XS::UnloadImage", XS_Graphics__Raylib__XS_UnloadImage);
        newXS_deffile("Graphics::Raylib::XS::UnloadMaterial", XS_Graphics__Raylib__XS_UnloadMaterial);
        newXS_deffile("Graphics::Raylib::XS::UnloadModel", XS_Graphics__Raylib__XS_UnloadModel);
        newXS_deffile("Graphics::Raylib::XS::UnloadMusicStream", XS_Graphics__Raylib__XS_UnloadMusicStream);
        newXS_deffile("Graphics::Raylib::XS::UnloadRenderTexture", XS_Graphics__Raylib__XS_UnloadRenderTexture);
        newXS_deffile("Graphics::Raylib::XS::UnloadShader", XS_Graphics__Raylib__XS_UnloadShader);
        newXS_deffile("Graphics::Raylib::XS::UnloadSound", XS_Graphics__Raylib__XS_UnloadSound);
        newXS_deffile("Graphics::Raylib::XS::UnloadSpriteFont", XS_Graphics__Raylib__XS_UnloadSpriteFont);
        newXS_deffile("Graphics::Raylib::XS::UnloadTexture", XS_Graphics__Raylib__XS_UnloadTexture);
        newXS_deffile("Graphics::Raylib::XS::UnloadWave", XS_Graphics__Raylib__XS_UnloadWave);
        newXS_deffile("Graphics::Raylib::XS::UpdateAudioStream", XS_Graphics__Raylib__XS_UpdateAudioStream);
        newXS_deffile("Graphics::Raylib::XS::UpdateCamera", XS_Graphics__Raylib__XS_UpdateCamera);
        newXS_deffile("Graphics::Raylib::XS::UpdateMusicStream", XS_Graphics__Raylib__XS_UpdateMusicStream);
        newXS_deffile("Graphics::Raylib::XS::UpdateSound", XS_Graphics__Raylib__XS_UpdateSound);
        newXS_deffile("Graphics::Raylib::XS::UpdateTexture", XS_Graphics__Raylib__XS_UpdateTexture);
        newXS_deffile("Graphics::Raylib::XS::UpdateVrTracking", XS_Graphics__Raylib__XS_UpdateVrTracking);
        newXS_deffile("Graphics::Raylib::XS::VectorToFloat", XS_Graphics__Raylib__XS_VectorToFloat);
        newXS_deffile("Graphics::Raylib::XS::WaveCopy", XS_Graphics__Raylib__XS_WaveCopy);
        newXS_deffile("Graphics::Raylib::XS::WaveCrop", XS_Graphics__Raylib__XS_WaveCrop);
        newXS_deffile("Graphics::Raylib::XS::WaveFormat", XS_Graphics__Raylib__XS_WaveFormat);
        newXS_deffile("Graphics::Raylib::XS::WindowShouldClose", XS_Graphics__Raylib__XS_WindowShouldClose);
#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

